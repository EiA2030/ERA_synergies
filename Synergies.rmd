---
title: "Evidence for Resilient Agriculture (ERA)"
authors: "Peter Steward, Todd Rosenstock"
date: "09/01/2024"
output: html_document
  #  toc: true
  #  toc_float: true
runtime: shiny
---

<style type="text/css">
.main-container {
  max-width: 1200px;
  margin-left: auto;
  margin-right: auto;
}
</style>

```{r Setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
knitr::opts_knit$set(root.dir = "..")
```

```{r Load packages,echo=FALSE,include=FALSE,message=FALSE,warning=FALSE}
# Check required packages are installed ####
if(!require("pacman", character.only = TRUE)){install.packages("pacman",dependencies = T)}

# Install ERAg and ERAgON

if(!require(ERAg)){
  if(!require("devtools", character.only = TRUE)){install.packages("devtools",dependencies = T)}
  devtools::install_github("EiA2030/ERAg@v1.0.1_beta")
}

if(!require(ERAgON)){
    if(!require("devtools", character.only = TRUE)){install.packages("devtools",dependencies = T)}
    devtools::install_github("ERAgON/ERAgON@ERAgON_1.0.0")
}

required.packages <- c("boot",
                       "broom",
                       "Cairo",
                       "colourpicker",
                       "data.table",
                       "doSNOW",
                       "DT",
                       "ggplot2",
                       "ggridges",
                       "grid",
                       "gridExtra",
                       "here",
                       "knitr",
                       "lme4",
                       "lmerTest",
                       "MASS",
                       "miceadds",
                       "pbapply",
                       "plotly",
                       "plyr",
                       "png",
                       "Rfast",
                       "rworldmap",
                       "sf",
                       "sfsmisc",
                       "shadowtext",
                       "shiny",
                       "spatstat",
                       "stringr",
                       "tidytext",
                       "treemap",
                       "viridis",
                       "weights")

p_load(char=required.packages,install = T,character.only = T)

  # Create function that balances the geometry of negative and positive changes by deciding numerator/denominator
  # based on whether T>C or T<C
  ERA.Change<-function(Exp,Con){
    Vals<- 100*(Exp/Con-1)
    Vals[Exp<Con]<- -100*((Con[Exp<Con]/Exp[Exp<Con])-1)
    return(Vals)
  }
```

```{r Detect cores, echo=F,eval=T}
cores<-max(1, parallel::detectCores() - 1)
```

```{r Create save directory for plots}
if(!dir.exists("./Plots")){
  dir.create("./Plots",recursive = T)
}
```

## Synergies and trade-offs when bundling agricultural management practices in Africa {.tabset .tabset-fade .tabset-pills}

```{r Prepare concepts & ERA dataset, echo=F,eval=T,warning=F}

  PracticeCodes <- data.table(ERAg::PracticeCodes)
  OutcomeCodes <-  data.table(ERAg::OutcomeCodes)
  EUCodes <-  data.table(ERAg::EUCodes)

  ERA<-ERAg::DeriveOutcomes(Data=data.table::copy(ERA.Compiled),
                       RmPartial=T,
                       DoWUE = T)
  
  # Remove feed substitution
  FeedSub<-paste0(PracticeCodes[grep("(Sub)",Subpractice),Subpractice.S],collapse="|")
  ERA<-ERA[!(grepl("Substitution",PrName)|grepl("Substitution",SubPrName.Base))]

  # To improve T.Descrip/C.Descrip matching remove spaces
  ERA[,C.Descrip:=gsub(" ","",C.Descrip)
      ][,T.Descrip:=gsub(" ","",T.Descrip)]
  
  # Prepare ERA dataset ####
  PercNeg<-0.5
  
  ERA.Econ<-suppressWarnings(ERAg::PrepareERA(
    Data=data.table::copy(ERA)[!is.na(MeanT) & !is.na(MeanC)], 
    CombineAll=F,
    DoCombinations=F,
    RmNeg=F,
    Perc.Neg = 100))

  ERA<-suppressWarnings(ERAg::PrepareERA(Data=ERA,CombineAll=F,DoCombinations=F,Perc.Neg=PercNeg,RmNeg=T))
  
  # Recalculate T/C ratio subtracting 1
  suppressWarnings(ERA[,pc:=100*((MeanT/MeanC)-1)][,yi:=log(MeanT/MeanC)])
  
  ERA<-ERA[!(is.infinite(yi)|is.na(yi)|is.infinite(pc)|is.na(pc))]
  
  ERA[,pc.ERA:=ERA.Change(Exp=MeanT,Con=MeanC)]
  
```
  
```{r Add linked datasets to ERA}
  
  # Add farming system to ERA
  LinkedDat<-data.table::copy(ERAgON::ERA_Other_Linked_Data)
  
  OtherVars<-c(FS_2012="FarmingSystem_2012.Mode")
  Cols<-c("Site.Key",as.vector(OtherVars))
  ERA<-merge(ERA,LinkedDat[,..Cols],by="Site.Key",all.x=T)
  
  for(i in 1:length(OtherVars)){
    setnames(ERA,OtherVars[i],"Value")
    ERA<-merge(ERA,ERA_Other_Linked_Data_Fields[[names(OtherVars)[i]]],by="Value",all.x=T)
    ERA[,Value:=NULL]
    setnames(ERA,"Description",names(OtherVars)[i])
  }
  
  ERA[is.na(AEZ5),AEZ16:=NA]

  # Create practice and outcome tables
  Prac.Levels<-data.table(ERAg::ERAConcepts$Prac.Levels)
  Out.Levels<-data.table(ERAg::ERAConcepts$Out.Levels)
  EU.Levels<-data.table(ERAg::ERAConcepts$Prod.Levels)

```


**Minimum data requirements & outlier removal:**
*Note that functional for practice and outcome aggregation levels is not yet implemented. Please retain default values in these fields*

:::: {style="display: flex;"}
::: {}
``` {r BP - choose practice level, echo=F}
# This functionality is not fully implemented yet

Section1.Input.Width<-"240px"

  selectInput("PLevel", "Level of pratice aggregation", 
    choices = Prac.Levels[,Choice], 
    selected = "Practice", 
    multiple = F,
    width=Section1.Input.Width)

BP.PLevel<-reactive({Prac.Levels[Choice==input$PLevel,Choice.Code]})
```
:::
:::{}
``` {r BP - choose outcome level, echo=F}
# This functionality is not fully implemented yet

  selectInput("OLevel", "Level of outcome aggregation", 
    choices = Out.Levels[,Choice], 
    selected = "Subindicator", multiple = F,
    width=Section1.Input.Width)

BP.OLevel<-reactive({Out.Levels[Choice==input$OLevel,Choice.Code]})
```
:::
:::{}
```{r BP - minimum studies, echo=F}
numericInput("Min.Studies","Min. No. studies required",5,min=1,max=500,step=1,width=Section1.Input.Width)  
```
:::
:::{}
```{r BP - minimum observations, echo=F}
numericInput("Min.Obs","Min. No. observations required",10,min=5,max=1000,step=1,width=Section1.Input.Width)
```
:::
:::{}
```{r BP - remove outliers, echo=F}
selectInput("rmOut", "Remove extreme outliers?", 
    choices = c("Yes","No"), 
    selected = "Yes", multiple =  F,
    width=Section1.Input.Width)
```
:::
::::

**Global plot settings:**

:::: {style="display: flex;"}
::: {}
```{r GP - Choose Palette,echo=F}
Section2.Input.Width<-"150px"

  selectInput(inputId="BP.Palette", 
              label="Choose palette",
              choices = c("magma","inferno","plasma","viridis","cividis","rocket","mako","turbo"),
              selected="viridis", 
              multiple = F, 
              width=Section2.Input.Width)
```
:::
:::{}
```{r GP - Adjust alpha}
numericInput(inputId="BP.Alpha",
             label="Adjust alpha",
             value=0.75,
             min=0,
             max=1,
             step=0.1, 
             width=Section2.Input.Width)
```
:::
:::{}
```{r GP - retain caption}
  selectInput(inputId="BP.Caption", 
              label="Retain plot caption?",
              choices = c("Yes","No"),
              selected="Yes", 
              multiple = F, 
              width=Section2.Input.Width)
```
:::
:::{}
```{r GP - Adjust Plot Height, echo=F}
numericInput(inputId="BP.Plot.Height",
             label="Adjust plot height",
             value=1,
             min=0.1,
             max=3,
             step=0.1, 
             width=Section2.Input.Width)
```
:::
:::{}
```{r GP - Adjust Plot Width , echo=F}
numericInput(inputId="BP.Plot.Width",
             label="Adjust plot width",
             value=1,
             min=0.1,
             max=3,
             step=0.1,
             width=Section2.Input.Width)
```
:::
:::{}
```{r GP - Adjust Global Font Size, echo=F}
numericInput(inputId="BP.Global.Font.Size",
             label="Adjust font size",
             value=14,
             min=1,
             max=20,
             step=1, 
             width=Section2.Input.Width)
```
:::
:::{}
```{r GP - Simple Bar Shorten Names}
  selectInput(inputId="BP.Bar.ShortNames", 
              label="Shorten names?",
              choices = c("Yes","No"),
              selected="Yes", 
              multiple = F,
              width="150px")
```
:::
::::

**Plot save settings:** Saved plots will be stored in a folder `/Plots` in working directory of this R project. Note Nature's standard figure sizes are 89 mm wide (single column) and 183 mm wide (double column) and should have minimum resolution of 600 DPI.

:::: {style="display: flex;"}
:::{}
```{r BigP - SaveFormat}
  selectInput(inputId="BP.Save.Format", 
              label="Save format",
              choices = c( "pdf", "jpeg", "tiff", "png"),
              selected="png", 
              multiple = F,
              width="100px")
```
:::
:::{}
```{r BigP - Plot Save Resolution, echo=F}
numericInput(inputId="BP.Save.Resolution",
             label="Plot DPI",
             value=600,
             min=300,
             max=1500,
             step=100,
             width="100px")
```
:::
:::{}
```{r BigP - Plot Scale, echo=F}
numericInput(inputId="BP.Save.Scale",
             label="Plot save scale",
             value=2,
             min=0.1,
             max=5,
             step=0.01,
             width="140px")
```
:::
::: {}
```{r BigP - Plot Save Width, echo=F}
numericInput(inputId="BP.Save.Width",
             label="Plot save width (mm)",
             value=89,
             min=1,
             max=1500,
             step=5,
             width="160px")
```
:::
:::{}
```{r BigP - Plot Save Height, echo=F}
numericInput(inputId="BP.Save.Height",
             label="Plot save height (mm)",
             value=89,
             min=1,
             max=1500,
             step=5,
             width="160px")
```
:::
::::

### A) General Methods

#### The Evidence for Resilient Agriculture (ERA) dataset
The ERA version being used in this analysis is `r packageVersion("ERAg")`.  

ERA is a systematic review and meta-dataset of peer-reviewed African agricultural research data published up to and including 2018. Details of ERA, including search protocols and inclusion criteria can be found in the ERAg package, we suggest reading the vignettes to familiarize yourself with the dataset. ERA includes detailed information on experimental location, dates, management practices, products, outcomes, units and quantitative results.   
Observations (rows) in ERA consist of paired outcome values from experimental vs control treatments (ETs vs CTs). An observation must have one or more improved management practices in the ET not that are present in the CT. An improved practice can either be an enhancement where an equivalent unimproved practice is present in the CT (e.g. comparing an improved to an unimproved crop variety), or an addition (e.g. inorganic fertilizer is used in the ET but not the CT). A CT cannot have an improved practice that is not present or differs to practices in the ET. If a management practice is shared between ETs and CTs it is called a base practice. In most instances base practices (and any other shared non-focal or unimproved management practices) should be identical between the CT and ET, however there are some pragmatic exceptions allowed, for example weed management can differ in comparisons of tillage methods.  

ERA uses a hierarchical classification system to structure and describe practices (3 tiers), outcomes (4 tiers) and products (3 tiers). In our analyses we use the lowest tier of outcome (subindicator), the mid-tier of practice (practice) and we aggregate across locations, products, and base practices.  

It should be noted that intercropping and rotation yield outcomes in ERA are reported for a focal main crop only and do not consider the total system performance. Intercropping yield outcomes typically shows reduced main crop performance due to spatial competition for resources, but inclusion of intercrops yields would improve the overall system result. Rotation outcomes may overestimate focal-crop yield benefits as yields of the non-focal rotation crops are not taken in account. Use of land equivalent ratios (LERs) may address these issues and this data is captured by ERA. Unfortunately, LER data are uncommonly reported in intercropping or rotation publications.

#### Derived outcomes
We combine exactly co-located outcome and environmental data (i.e., identical management, location, and timeframe) to derive new outcomes. Derived outcomes include net returns, gross margin, benefit cost ratios, water use efficiency and nitrogen total factor productivity. 

#### Exclusion criteria
* Observations with infinite ET/CT ratios (i.e., where the control value was zero) are excluded.  
* Outcomes which can have negative values (e.g., net returns) can generate meaningless ratios if the signs of control and experimental values are divergent (one positive and one negative). Any combinations of practice bundle and outcome where more than 0.5 percent of observation have divergent signs are excluded.  
* Partial economic outcomes, such as marginal returns or marginal variable costs, and non-crop products are also excluded from analysis.  

#### Inversion of outcomes
Sometimes lower values indicate a better outcome, for example carbon dioxide emissions, soil erosion and rainfall runoff outcomes are better when lower. For such outcomes ET and CT outcomes values are swapped inverting the outcome ratio used in analyses. ET and CT values are also swapped when both were negative as less negative values indicate a better outcome (of course taking into account the previous statement).

#### Outlier removal
Whilst allowing the aggregation of outcomes from diverse studies and units of measurement, the use of experimental vs control treatment ratios has its limitations. One major issue occurs when the control tends to zero. This dramatically inflates the ET/CT ratio towards infinity which can badly and unrealistically skew the distribution of results. In crop yield experiments this can occur when the yield of the control treatment has collapsed but not the experimental treatment. This could occur when there are unequal impacts of environmental stressors such as drought, heavy rainfall, pest or diseases. To counter the influence of extremely high ET/CT ratios we remove extreme outliers prior to analysis. Within combinations of practice and outcome extreme response ratio, as ln(ET/CT)), outliers beyond three interquartile ranges from the mean were excluded from the data. We recognise that outlier removal is a hotly debated topic and the is an option above to allow or prevent outlier removal. 

#### Weightings
A common failing of agricultural publications in the ERA dataset is that errors are often omitted or presented in an unusable form. As such using Z-statistics that require a measure of sample variance is not possible Instead we calculated bservations weightings as $\frac{Rep_{c.ijkl}*Rep_{t.ijkl}}{Rep_{c.ijkl}+Rep_{t.ijkl}}/\sum_{jkl}^{n}$ where $Rep_c$ & $Rep_t$ are the number of replicates for the control and experimental treatments, $i$ is the observation, $j$ is the experiment/study, $k$ is the practice level and $l$ is the outcome level.For any subset of data analysed the contributions of individual datapoints are down weighted by the total number of observations contributed by a study. Thus, studies should contribute equally to an analysis and data-points are weighted by replication as a proxy for reliability.

#### Minimum data requirements
In the resampling and classification approach each combination of bundle and outcome required five or more studies contributing at least ten observations in total for each bundle and its component practices. For the agronomic productivity gain approach each combination of practice, base practice and outcome also required five or more studies giving ten or more observations. Minimum data requirements can be changed above. 

### B) Approach 1 - Synergies {.tabset .tabset-fade .tabset-pills}

#### B1) Co-located Data  {.tabset .tabset-fade .tabset-pills}

```{r Colocated - use pc or Diff, echo=F}
selectInput("Colocated.Method", "Use ratios or difference for classification?", 
    choices = c("Ratios","Difference"), 
    selected = "Difference", multiple =  F)
```

```{r Colocated - create functions, echo = F}
# Extract and classify date
ColocatedFun<-function(Data,rmOut,PLevel,OLevel,RemoveInt,Min.Studies,Min.Obs,SaveDir){
  
  if(!is.na(SaveDir) & substr(SaveDir,nchar(SaveDir),nchar(SaveDir))!="/"){
    SaveDir<-paste0(SaveDir,"/")
  }
  
  if(!dir.exists(SaveDir)){
    dir.create(SaveDir,recursive=T)
  }
  
  G.Dat.File<-paste0("G.Dat-",PLevel[,Prac],"-",OLevel,"-",rmOut,"-",Min.Studies,"-",Min.Obs,".RData")
  G.Dat.Path<-paste0(SaveDir,G.Dat.File)
  
  if(file.exists(G.Dat.Path)){
    G.Dat<-miceadds::load.Rdata2(G.Dat.File,path=SaveDir)
  }else{
    
    # Generate all components of an interaction
    GenCombo<-function(Name,Delim){
      NPracs<-str_count(Name[1],Delim)+1
      Pracs<-unlist(lapply(1:NPracs,FUN=function(j){
        combn(unlist(strsplit(Name,Delim)),m=j,FUN=paste,collapse=Delim)
      }))
      return(Pracs)
    }
    
    # Create a simple function to detect extreme outliers ####
    Out.Calc<-function(Vals){
      return((Vals < quantile(Vals)[2] - 3 *  IQR(Vals)  | Vals > quantile(Vals)[4] + 3 * IQR(Vals)))
    }
    
    # Rename columns ####
    setnames(Data,OLevel,"Outcome")
    setnames(Data,PLevel[,Prac],"Practice")
    setnames(Data,PLevel[,Base],"Base.Practice")
    
    Aggregate.By<-c("Practice","Outcome")
    
    # Make sure practices are ordered alphabetically ####
    FunB<-function(X){
      Z<-unlist(strsplit(X,"-"))
      paste(Z[order(Z)],collapse="-")
    }
    Data[,Practice:=FunB(Practice[1]),by=Practice]
    Data[,Base.Practice:=FunB(Base.Practice[1]),by=Base.Practice]
    
    # Remove practices that contain NA practices ####
    Data<-Data[!grepl("NA",Practice)]
    
    # Remove Outliers? ####
    if(rmOut){
      Outliers<-unlist(Data[,R:=1:nrow(Data)
      ][,list(Outliers=list(R[Out.Calc(yi)])), by=Aggregate.By
      ][,Outliers])
      
      Data<-Data[!Outliers]
    }
    
    # Add Weights ####
    Weight.Group<-unique(c("Code",Aggregate.By))
    
    # Make function to check if all components for a practice are present
    # Needs to be nuanced in that Tree, Variety and Diversity should only be present if they are not part of the interaction.
    
    # Subset interactions to those that meet minimum data requirements ####
    Combinations<-Data[grep("-",Practice),list(NPracs=str_count(Practice[1],"-")+1),by=Aggregate.By]
    
    Var.Cols<-c("Rep","MeanC","MeanT","Practice","plist","Outcode","Outcome") 
    Grouping.Cols<-c("Code","Site.ID","Site.Key","C.Descrip","EU","M.Year","C.NI","C.NO","base.list","Base.Practice")
   
    if(PLevel[,Prac]=="SubPrName"){
      Treats<-c("Inorganic Fertilizer","Organic Fertilizer",unique(as.character(PracticeCodes$Practice[PracticeCodes$Theme=="Agroforestry"])),"Improved Varieties","Crop Rotation","Intercropping")
      Treat.Cols<-c("T.NI","T.NO",rep("Tree",length(unique(PracticeCodes$Practice[PracticeCodes$Theme=="Agroforestry"]))),"Variety","Diversity","Diversity")
    }else{
      Treats<-c("Inputs N",
               PracticeCodes[Practice=="Organic Fertilizer",Subpractice],
               PracticeCodes[Theme=="Agroforestry",Subpractice],
               PracticeCodes[Practice %in% c("Improved Varieties","Genetic Improvement"),Subpractice],
               PracticeCodes[Practice %in% c("Crop Rotation","Intercropping"),Subpractice])
               
      Treat.Cols<-c("T.NI",
                    rep("T.NO",length(PracticeCodes[Practice=="Organic Fertilizer",Subpractice])),
                    rep("Tree",length(PracticeCodes[Theme=="Agroforestry",Subpractice])),
                    rep("Variety",length(PracticeCodes[Practice %in% c("Improved Varieties","Genetic Improvement"),Subpractice])),
                    rep("Diversity",length(PracticeCodes[Practice %in% c("Crop Rotation","Intercropping"),Subpractice])))
    }
    All.Cols<-unique(c(Var.Cols,Grouping.Cols,Treat.Cols))
    Data<-Data[,..All.Cols]
    
    AllPresentFun<-function(Int.Practice,Int.Outcome,Grouping.Cols,Data,SplitCols,Treats,Treat.Cols,Min.Studies,Min.Obs){
       PRACS<-unlist(strsplit(Int.Practice,"-"))
      All.PRACS<-c(PRACS,Int.Practice)
      Cols<-c(Grouping.Cols,unique(Treat.Cols[!Treat.Cols %in% Treat.Cols[Treats %in% PRACS]]))
      X<-Data[Practice %in% All.PRACS & Outcome==Int.Outcome,]
      if(nrow(X)>0){
        suppressWarnings(X[,IDx:=apply(X[,..Cols],1,paste,collapse="-")][,IDx:=as.numeric(as.factor(IDx))])
        X[,Both.Pracs.Present:=sum(unique(Practice) %in% All.PRACS)==length(All.PRACS),by=IDx]
        X<-X[Both.Pracs.Present!=F]
        if(nrow(X)>0){
          
          # If Reps differ then average and round
          X[,Rep:=round(mean(Rep),0),by=list(M.Year,Code,Outcome,IDx,Site.ID,EU)]
          # If controls differ then average and round
          X[,MeanC:=mean(MeanC),by=list(M.Year,Code,Outcome,IDx,Site.ID,EU)]
          
          X[,pc:=100*((MeanT/MeanC)-1)]
          X<-dcast(X,Code+Outcome+IDx+Rep+M.Year+MeanC~Practice,value.var = c("MeanT","pc"),fun.aggregate = list(mean,length))
          X[,Interaction:=Int.Practice]
          
          X[,N.Obs.Study:=.N,by=Code # Recalculate Weightings by study within observations grouping 
          ][,Weight.Study:=(Rep^2/(2*Rep))/N.Obs.Study # Recalculate Weightings
          ][,N.Studies:=length(unique(Code))
          ][,N.Obs.Int:=.N]
          
          # rename columns
          colnames(X)<-gsub(Int.Practice,"AB",colnames(X),fixed=T)
          
          for(i in 1:length(PRACS)){
            colnames(X)<-gsub(PRACS[i],LETTERS[i],colnames(X),fixed=T)
          }
          colnames(X)<-gsub("MeanT_mean_","Mean_",colnames(X),fixed=T)
          colnames(X)<-gsub("pc_mean_","pc_",colnames(X),fixed=T)
          colnames(X)<-gsub("MeanT_length_","N_",colnames(X),fixed=T)
          
          Rm.Cols<-grep("pc_length",colnames(X),value = T)
          X<-X[,!..Rm.Cols]    
          
          Comp.Cols<-colnames(X)[grepl("pc_",colnames(X)) & !grepl("pc_AB",colnames(X))]
          suppressWarnings(X[,pc_sum:=rowSums(X[,..Comp.Cols])])
          
          if(nrow(X)>=Min.Obs & X[,length(unique(Code))>Min.Studies]){
            suppressWarnings(A<-wtd.t.test(x=X[,pc_AB],y=X[,pc_sum],weight=X[,Weight.Study],alternative="greater"))
            
            suppressWarnings(B<-wtd.t.test(x=X[,pc_AB],y=X[,pc_sum],weight=X[,Weight.Study],alternative="less"))
            
            Y<-rbind(
              data.table(direction="Greater",t(data.frame(A$coefficients)),t(data.frame(A$additional))),
              data.table(direction="Less",t(data.frame(B$coefficients)),t(data.frame(B$additional)))
            )[,Outcome:=Int.Outcome][,Practice:=Int.Practice][,Component:="Summed"]
            
            for(j in 1:length(Comp.Cols)){
              C.Col<-Comp.Cols[j]
              suppressWarnings(A<-wtd.t.test(x=X[,pc_AB],y=unlist(X[,..C.Col]),weight=X[,Weight.Study],alternative="greater"))
              
              suppressWarnings(B<-wtd.t.test(x=X[,pc_AB],y=unlist(X[,..C.Col]),weight=X[,Weight.Study],alternative="less"))
              
              
              Z<-rbind(
                data.table(direction="Greater",t(data.frame(A$coefficients)),t(data.frame(A$additional))),
                data.table(direction="Less",t(data.frame(B$coefficients)),t(data.frame(B$additional)))
              )[,Outcome:=Int.Outcome][,Practice:=Int.Practice][,Component:=PRACS[j]]
              
              Y<-rbind(Y,Z)
              
            }
            
            colnames(Y)<-gsub("Std. Err","SE",colnames(Y))
            return(list(Raw.Data=X,Test.Data=Y))
            
          }else{
            return(list(Raw.Data=X,Test.Data=NULL))
            
          }
          
          
        }}else{}
    }
    
    Combo.Data<-pblapply(1:nrow(Combinations),FUN=function(i){
      X<-AllPresentFun(Int.Practice=Combinations[i,Practice],
                       Int.Outcome=Combinations[i,Outcome],
                       Grouping.Cols=Grouping.Cols,
                       Data=data.table::copy(Data),
                       Treats=Treats,
                       Treat.Cols=Treat.Cols,
                       Min.Studies = Min.Studies,
                       Min.Obs = Min.Obs)
    })
    
    Test.Data<-rbindlist(lapply(Combo.Data,"[[","Test.Data"))
    
    Test.Data<-dcast(Test.Data,Practice+Component+Outcome+Mean.x+Mean.y+SE+t.value+df+Difference~direction,value.var =   "p.value")
    Test.Data[,PxO:=paste0(Practice,"-",Outcome)]
    
    Class<-pblapply(Test.Data[,unique(PxO)],FUN=function(PXO){
      X<-Test.Data[PxO==PXO]
      COMP<-unlist(strsplit(X[1,Practice],"-"))
      
      X<-dcast(X,formula=Mean.x+Outcome+Practice~Component,value.var = c("Mean.y","Difference","SE","Greater","Less"))
      setnames(X,"Mean.x","pc_Int")  
      setnames(X,"Mean.y_Summed","pc_sum")  
      
      COMP.PC<-paste0("Mean.y_",COMP)
      COMP.LESS.s<-paste0("Less_",COMP)
      COMP.GTR.s<-paste0("Greater_",COMP)
      
      suppressWarnings(X[,Greater_Max:=unlist(lapply(1:nrow(X),FUN=function(i){
        unique(unlist(X[i,..COMP.GTR.s])[unlist(X[i,..COMP.PC]==max(X[i,..COMP.PC]))])
      }))])
      
      # Determine directionality of component scores ####
      X[,Diff.Type.pc:=as.character(NA)]
      
      X[,Diff.Type.pc:="Divergent"]
      X[apply(X[,..COMP.PC],1,FUN=function(Y){all(Y>=0)}),Diff.Type.pc:="Positive"]
      X[apply(X[,..COMP.PC],1,FUN=function(Y){all(Y<=0)}),Diff.Type.pc:="Negative"]
      X[apply(X[,..COMP.PC],1,FUN=function(Y){all(Y==0)}),Diff.Type.pc:="Zero"]
      suppressWarnings(X[,pc_max:=apply(X[,..COMP.PC],1,max)])
      suppressWarnings(X[,pc_min:=apply(X[,..COMP.PC],1,min)])
      
      # pc_max_div - for divergent practices which is higher the max or the sum of the components (for n>2 practices) ####
      X[,N:=1:.N][,pc_max_div:=max(pc_max,pc_sum),by=N][,N:=NULL]
      X[,N:=1:.N][,Greater_Max_Div:=max(Greater_Max,Greater_Summed),by=N]
      
      # Classify Interactions #####
      X[,Diff.Cat.pc:=as.character(NA)]
      
      # Antagonistic
      X[pc_Int<pc_min,Diff.Cat.pc:="Antagonistic"] # Int<(A|B) same no matter what the difference type
      suppressWarnings(X[,Antagonistic.Sig:=apply(X[,..COMP.LESS.s],1,max)])
      
      # Averaging
      X[pc_Int>=pc_min & pc_Int<=pc_max,Diff.Cat.pc:="Averaging"] 
      
      # Choose sub component significance based on direction of difference and take the max significance of the all subcomponents
      Z<-X[Diff.Cat.pc=="Averaging",pc_Int]<X[Diff.Cat.pc=="Averaging",..COMP.PC]
      suppressWarnings(X[Diff.Cat.pc=="Averaging",Averaging.Sig:=apply(pmax(Z*X[Diff.Cat.pc=="Averaging",..COMP.LESS.s],(!Z)*X[Diff.Cat.pc=="Averaging",..COMP.GTR.s]),1,max)])
      
      # Positive Component Scores
      #Int<=(A+B) & Int>max(A|B)
      X[pc_Int<=pc_sum & pc_Int>pc_max & Diff.Type.pc %in% c("Positive","Zero"),Diff.Cat.pc:="Additive"]
      X[Diff.Type.pc %in% c("Positive","Zero"),Additive.Sig:=Greater_Max]
      
      # Int>(A+B)
      X[pc_Int>=pc_sum & Diff.Type.pc %in% c("Positive","Zero"),Diff.Cat.pc:="Superadditive"]
      X[Diff.Type.pc %in% c("Positive","Zero"),Superadditive.Sig:=Greater_Summed]
      
      # Divergent & Negative Component Scores
      if(any(X[,Diff.Type.pc] %in%  c("Divergent","Negative"))){
        X[pc_Int>pc_max_div & Diff.Type.pc %in% c("Divergent","Negative"),Diff.Cat.pc:="Superadditive"] 
        Z<-rowSums(X[Diff.Type.pc %in% c("Divergent","Negative"),list(Greater_Summed,Greater_Max)] * matrix(X[Diff.Type.pc %in% c("Divergent","Negative"),c(pc_sum,pc_max)==max(pc_sum,pc_max),by=N][,V1],ncol = 2,byrow = T))
        X[Diff.Type.pc %in% c("Divergent","Negative"),Superadditive.Sig:=Z]
        
        X[pc_Int<pc_max_div & pc_Int>pc_max & Diff.Type.pc %in% c("Divergent","Negative"),Diff.Cat.pc:="Additive"] 
        X[pc_Int<pc_max_div & pc_Int>pc_max & Diff.Type.pc %in% c("Divergent","Negative"),Additive.Sig:=Greater_Max] 
      }
      
      # Ratio of interaction (Int) to sum of components 
      X[,Ratio.sum:=pc_Int/pc_sum]
      # Ratio of interaction (int) to highest of max component or sum of components
      X[,Ratio.max:=pc_Int/pc_max_div]
      
      X
    })
    
    Raw.Data<-lapply(Combo.Data,"[[","Raw.Data")
    names(Raw.Data)<-Combinations[,paste0(Practice,"-",Outcome)]
    
    Class.Raw<-pblapply(Test.Data[,unique(PxO)],FUN=function(PXO){
      X<-data.table::copy(Raw.Data[[PXO]])
      setnames(X,"pc_AB","pc_Int")
      
      COMP<-unlist(strsplit(X[1,Interaction],"-"))
      
      
      COMP.PC<-colnames(X)[grepl("pc_",colnames(X)) & !grepl("pc_Int",colnames(X)) & !grepl("pc_sum",colnames(X))]
      
      # Determine directionality of component scores ####
      X[,Diff.Type.pc:=as.character(NA)]
      
      X[,Diff.Type.pc:="Divergent"]
      X[apply(X[,..COMP.PC],1,FUN=function(Y){all(Y>=0)}),Diff.Type.pc:="Positive"]
      X[apply(X[,..COMP.PC],1,FUN=function(Y){all(Y<=0)}),Diff.Type.pc:="Negative"]
      X[apply(X[,..COMP.PC],1,FUN=function(Y){all(Y==0)}),Diff.Type.pc:="Zero"]
      suppressWarnings(X[,pc_max:=apply(X[,..COMP.PC],1,max)])
      suppressWarnings(X[,pc_min:=apply(X[,..COMP.PC],1,min)])
      
      # pc_max_div - for divergent practices which is higher the max or the sum of the components (for n>2 practices) ####
      X[,N:=1:.N][,pc_max_div:=max(pc_max,pc_sum),by=N][,N:=NULL]
      
      # Classify Interactions #####
      X[,Diff.Cat.pc:=as.character(NA)]
      
      # Antagonistic
      X[pc_Int<pc_min,Diff.Cat.pc:="Antagonistic"] # Int<(A|B) same no matter what the difference type
      
      # Averaging
      X[pc_Int>=pc_min & pc_Int<=pc_max,Diff.Cat.pc:="Averaging"] 
      
      # Choose sub component significance based on direction of difference and take the max significance of the all subcomponents
      Z<-X[Diff.Cat.pc=="Averaging",pc_Int]<X[Diff.Cat.pc=="Averaging",..COMP.PC]
      
      # Positive Component Scores
      #Int<=(A+B) & Int>max(A|B)
      X[pc_Int<=pc_sum & pc_Int>pc_max & Diff.Type.pc %in% c("Positive","Zero"),Diff.Cat.pc:="Additive"]
      
      # Int>(A+B)
      X[pc_Int>=pc_sum & Diff.Type.pc %in% c("Positive","Zero"),Diff.Cat.pc:="Superadditive"]
      
      # Divergent & Negative Component Scores
      if(any(X[,Diff.Type.pc] %in%  c("Divergent","Negative"))){
        X[pc_Int>pc_max_div & Diff.Type.pc %in% c("Divergent","Negative"),Diff.Cat.pc:="Superadditive"] 
        X[pc_Int<pc_max_div & pc_Int>pc_max & Diff.Type.pc %in% c("Divergent","Negative"),Diff.Cat.pc:="Additive"] 
      }
      
      # Ratio of interaction (Int) to sum of components 
      X[,Ratio.sum:=pc_Int/pc_sum]
      # Ratio of interaction (int) to highest of max component or sum of components
      X[,Ratio.max:=pc_Int/pc_max_div]
      
      X
      
    })
    names(Class.Raw)<-Test.Data[,unique(PxO)]
    
    ClassSummary<-rbindlist(pblapply(1:length(Class),FUN=function(i){
      X<-data.table::copy(Class[[i]])
      PXO<-X[,paste0(Practice,"-",Outcome)]
      X.Raw<-Class.Raw[[PXO]]
      
      # Max of components  
      cols<-grep("Mean.y",colnames(X),value = T)
      Y<-X[,..cols]
      MaxComp<-max(Y)
      
      
      PRACTICE<-X[1,Practice]
      PRACS<-GenCombo(PRACTICE,"-")
      if(RemoveInt){
        PRACS<-c(PRACTICE,PRACS[!grepl("-",PRACS)])
      }
      OUTCOME<-X[1,Outcome]
      
      Y4<-Raw.Data[[PXO]]
      Y4<-data.table(N.Studies=Y4[,length(unique(Code))],N.Obs.Prac=nrow(Y4))
      
      data.table(
        Practice=PRACS[1],
        Outcome=OUTCOME,
        Y4,
        Int_pc = X[,pc_Int],
        MaxComps_pc = MaxComp,
        SumComps_pc = X[,pc_sum],
        Diff.Cat = X[,Diff.Cat.pc],
        Superadditive.Sig = X[Diff.Cat.pc=="Superadditive",mean(Superadditive.Sig)],
        Additive.Sig = X[Diff.Cat.pc=="Additive",mean(Additive.Sig)],
        Averaging.Sig = X[Diff.Cat.pc=="Averaging",mean(Averaging.Sig)],
        Antagonistic.Sig = X[Diff.Cat.pc=="Antagonistic",mean(Antagonistic.Sig)],
        
        Superadditive.Pr = X.Raw[,sum(Diff.Cat.pc=="Superadditive")/.N],
        Additive.Pr = X.Raw[,sum(Diff.Cat.pc=="Additive")/.N],
        Averaging.Pr = X.Raw[,sum(Diff.Cat.pc=="Averaging")/.N],
        Antagonistic.Pr = X.Raw[,sum(Diff.Cat.pc=="Antagonistic")/.N],
        
        Diff.Type=X[,Diff.Type.pc],
        
        Positive.Pr=X.Raw[,sum(Diff.Type.pc=="Positive")/.N],
        Divergent.Pr=X.Raw[,sum(Diff.Type.pc=="Divergent")/.N],
        Negative.Pr=X.Raw[,sum(Diff.Type.pc=="Negative")/.N]
      )
    }))
    
    G.Dat<-list(Boot.Data=Combo.Data,Class=Class,ClassSummary=ClassSummary,Raw.Data=Raw.Data)
    save(G.Dat,file=G.Dat.Path)
    
  }

  
  return(G.Dat)
}

# Potential improvement to the below is to add weightings when calculating proportions
ColocatedFun.Diff<-function(Data,PLevel,OLevel,RemoveInt,Min.Studies,Min.Obs,SaveDir){
  
  getmode <- function(v) {
    uniqv <- unique(v)
    uniqv[which.max(tabulate(match(v, uniqv)))]
  }
  
  
  if(!is.na(SaveDir)){
     
    if(substr(SaveDir,nchar(SaveDir),nchar(SaveDir))!="/"){
    SaveDir<-paste0(SaveDir,"/")
  }
  
  if(!dir.exists(SaveDir)){
    dir.create(SaveDir,recursive=T)
  }
  
  G.Dat.File<-paste0("G.Dat-",PLevel[,Prac],"-",OLevel,"-",Min.Studies,"-",Min.Obs,".RData")
  G.Dat.Path<-paste0(SaveDir,G.Dat.File)
  
  }else{
    G.Dat.Path<-"NOPATH"
  }
  
  if(file.exists(G.Dat.Path)){
    G.Dat<-miceadds::load.Rdata2(G.Dat.File,path=SaveDir)
  }else{
    
    # Generate all components of an interaction
    GenCombo<-function(Name,Delim){
      NPracs<-str_count(Name[1],Delim)+1
      Pracs<-unlist(lapply(1:NPracs,FUN=function(j){
        combn(unlist(strsplit(Name,Delim)),m=j,FUN=paste,collapse=Delim)
      }))
      return(Pracs)
    }
    
    # Rename columns ####
    setnames(Data,OLevel,"Outcome")
    setnames(Data,PLevel[,Prac],"Practice")
    setnames(Data,PLevel[,Base],"Base.Practice")
    
    Aggregate.By<-c("Practice","Outcome")
    
    # Make sure practices are ordered alphabetically ####
    FunB<-function(X){
      Z<-unlist(strsplit(X,"-"))
      paste(Z[order(Z)],collapse="-")
    }
    Data[,Practice:=FunB(Practice[1]),by=Practice]
    Data[,Base.Practice:=FunB(Base.Practice[1]),by=Base.Practice]
    
    # Remove practices that contain NA practices ####
    Data<-Data[!grepl("NA",Practice)]
    
    # Remove Outliers? ####
    # Not allowed as the analysis is based on differences
    if(F){
      Outliers<-unlist(Data[,R:=1:nrow(Data)
      ][,list(Outliers=list(R[Out.Calc(MeanT/MeanC)])), by=Aggregate.By
      ][,Outliers])
      
      Data<-Data[!Outliers]
    }
    
    # Add Weights ####
    Weight.Group<-unique(c("Code",Aggregate.By))
    
    # Make function to check if all components for a practice are present
    # Needs to be nuanced in that Tree, Variety and Diversity should only be present if they are not part of the interaction.
    
    # Subset interactions to those that meet minimum data requirements ####
    Combinations<-Data[grep("-",Practice),list(NPracs=str_count(Practice[1],"-")+1),by=Aggregate.By]
    
    Var.Cols<-c("Rep","MeanC","MeanT","Practice","plist","Outcode","Outcome") 
    Grouping.Cols<-c("Code","Site.ID","ID","C.Descrip","EU","M.Year","C.NI","C.NO","base.list","Base.Practice","Units")
    Treats<-c("Inorganic Fertilizer","Organic Fertilizer",unique(as.character(PracticeCodes$Practice[PracticeCodes$Theme=="Agroforestry"])),"Improved Varieties","Crop Rotation","Intercropping")
    Treat.Cols<-c("T.NI","T.NO",rep("Tree",length(unique(PracticeCodes$Practice[PracticeCodes$Theme=="Agroforestry"]))),"Variety","Diversity","Diversity")
    
    All.Cols<-unique(c(Var.Cols,Grouping.Cols,Treat.Cols))
    Data<-Data[,..All.Cols]
    
    AllPresentFun<-function(Int.Practice,Int.Outcome,Grouping.Cols,Data,SplitCols,Treats,Treat.Cols,Min.Studies,Min.Obs){ 
      PRACS<-unlist(strsplit(Int.Practice,"-"))
      All.PRACS<-c(PRACS,Int.Practice)
      Cols<-c(Grouping.Cols,unique(Treat.Cols[!Treat.Cols %in% Treat.Cols[Treats %in% PRACS]]))
      X<-Data[Practice %in% All.PRACS & Outcome==Int.Outcome,]
     
      if(nrow(X)>0){
        suppressWarnings(X[,IDx:=apply(X[,..Cols],1,paste,collapse="-")][,IDx:=as.numeric(as.factor(IDx))])
        X[,Both.Pracs.Present:=sum(unique(Practice) %in% All.PRACS)==length(All.PRACS),by=IDx]
        X<-X[Both.Pracs.Present!=F]
        if(nrow(X)>0){
          
          # If Reps differ then average and round
          X[,Rep:=round(mean(Rep),0),by=list(M.Year,Code,Outcome,IDx,Site.ID,EU,Units)
            # If controls differ then average and round
              ][,Diff:=MeanT-MeanC]
 
          X<-dcast(X,Code+Outcome+IDx+Rep+M.Year+Units~Practice,value.var = "Diff",fun.aggregate = list(mean,length))
          
          X[,Interaction:=Int.Practice
            ][,N.Obs.Study:=.N,by=Code # Recalculate Weightings by study within observations grouping 
              ][,Weight.Study:=(Rep^2/(2*Rep))/N.Obs.Study # Recalculate Weightings
                ][,N.Studies:=length(unique(Code))
                  ][,N.Obs.Int:=.N]
          
          # rename columns
          colnames(X)<-gsub(Int.Practice,"AB",colnames(X))
          
          for(i in 1:length(PRACS)){
            colnames(X)<-gsub(PRACS[i],LETTERS[i],colnames(X))
          }
          colnames(X)<-gsub("Diff_mean_","Diff_",colnames(X))
          colnames(X)<-gsub("Diff_length_","N_",colnames(X))
          
          Comp.Cols<-colnames(X)[grepl("Diff_",colnames(X)) & !grepl("Diff_AB",colnames(X))]
          
          X.Dat<-as.matrix(X[,..Comp.Cols])
          
          X[,Diff_sum:=rowSums(X.Dat)
            ][,Diff_min:=Rfast::rowMins(X.Dat,value=T)
              ][,Diff_max:=Rfast::rowMaxs(X.Dat,value=T)
                ][,Diff.AB.sum:=Diff_AB-Diff_sum
                  ][,Diff.AB.max:=Diff_AB-Diff_max
                    ][,Diff.AB.min:=Diff_AB-Diff_min]

        }}else{}
    }
    
    Combo.Data<-pblapply(1:nrow(Combinations),FUN=function(i){
      X<-AllPresentFun(Int.Practice=Combinations[i,Practice],
                       Int.Outcome=Combinations[i,Outcome],
                       Grouping.Cols=Grouping.Cols,
                       Data=data.table::copy(Data),
                       Treats=Treats,
                       Treat.Cols=Treat.Cols,
                       Min.Studies = Min.Studies,
                       Min.Obs = Min.Obs)
    })
    
    
    Diff.Data<-rbindlist(Combo.Data,fill=T)
    
    Diff.Data[,PxO:=paste0(Interaction,"-",Outcome)]
    
    DIFF.COLS<-colnames(Diff.Data)[grepl("Diff_",colnames(Diff.Data)) & !grepl("min|max|sum|AB",colnames(Diff.Data))]
    
    Class<-rbindlist(pblapply(Diff.Data[,unique(PxO)],FUN=function(PXO){
      X<-Diff.Data[PxO==PXO]
      COMP<-unlist(strsplit(X[1,Interaction],"-"))

      # Determine directionality of component scores ####
      X[,Diff.Type.pc:=as.character(NA)]
      
      X[,Diff.Type.pc:="Divergent"]
      X[apply(X[,..DIFF.COLS],1,FUN=function(Y){all(Y[!is.na(Y)]>=0)}),Diff.Type.pc:="Positive"]
      X[apply(X[,..DIFF.COLS],1,FUN=function(Y){all(Y[!is.na(Y)]<=0)}),Diff.Type.pc:="Negative"]
      X[apply(X[,..DIFF.COLS],1,FUN=function(Y){all(Y[!is.na(Y)]==0)}),Diff.Type.pc:="Zero"]

      # pc_max_div - for divergent practices which is higher the max or the sum of the components (for n>2 practices) ####
      X[,N:=1:.N][,Diff_max_div:=max(Diff_max,Diff_sum),by=N][,N:=NULL]

      # Classify Interactions #####
      X[,Diff.Cat.pc:=as.character(NA)]
      
      # Antagonistic
      X[Diff_AB<Diff_min,Diff.Cat.pc:="Antagonistic"] # Int<(A|B) same no matter what the difference type

      # Averaging
      X[Diff_AB>=Diff_min & Diff_AB<=Diff_max,Diff.Cat.pc:="Averaging"] 
      
      # Positive Component Scores
      #Int<=(A+B) & Int>max(A|B)
      X[Diff_AB<=Diff_sum & Diff_AB>Diff_max & Diff.Type.pc %in% c("Positive","Zero"),Diff.Cat.pc:="Additive"]

      # Int>(A+B)
      X[Diff_AB>=Diff_sum & Diff.Type.pc %in% c("Positive","Zero"),Diff.Cat.pc:="Superadditive"]

      # Divergent & Negative Component Scores
      if(any(X[,Diff.Type.pc] %in%  c("Divergent","Negative"))){
        X[Diff_AB>Diff_max_div & Diff.Type.pc %in% c("Divergent","Negative"),Diff.Cat.pc:="Superadditive"] 

        X[Diff_AB<Diff_max_div & Diff_AB>Diff_max & Diff.Type.pc %in% c("Divergent","Negative"),Diff.Cat.pc:="Additive"] 
      }
      
      # Ratio of interaction (Int) to sum of components 
      X[,Ratio.sum:=Diff_AB/Diff_sum]
      # Ratio of interaction (int) to highest of max component or sum of components
      X[,Ratio.max:=Diff_AB/Diff_max_div]
      
      X
    }))
    
    Raw.Data<-lapply(Combo.Data,"[[","Raw.Data")
    names(Raw.Data)<-Combinations[,paste0(Practice,"-",Outcome)]
    
    Dcols<-grep("Diff_|.sum|.min|.max|PxO",colnames(Class),value=T,invert = T)
    ClassSummary<-data.table::copy(Class)[,..Dcols][,N:="N_A"]
    Ncols<-grep("N_",colnames(ClassSummary),value=T,invert = T)
    ClassSummary<-ClassSummary[,..Ncols]
    
    ClassSummary<-ClassSummary[,list(
      Diff.Cat=getmode(Diff.Cat.pc),
      Diff.Type=getmode(Diff.Type.pc),
      Superadditive.Pr=sum(Diff.Cat.pc=="Superadditive")/.N,
      Additive.Pr=sum(Diff.Cat.pc=="Additive")/.N,
      Averaging.Pr=sum(Diff.Cat.pc=="Averaging")/.N,
      Antagonistic.Pr=sum(Diff.Cat.pc=="Antagonistic")/.N,
      Positive.Pr=sum(Diff.Type.pc=="Positive")/.N,
      Divergent.Pr=sum(Diff.Type.pc=="Divergent")/.N,
      Negative.Pr=sum(Diff.Type.pc=="Negative")/.N,
      N.Studies=mean(N.Studies),
      N.Obs.Prac=mean(N.Obs.Int)),
      by=list(Interaction,Outcome)]
    
    setnames(ClassSummary,"Interaction","Practice")
    
    G.Dat<-list(Class=Class,ClassSummary=ClassSummary)
    
    if(!is.na(SaveDir)){
    save(G.Dat,file=G.Dat.Path)
    }
    
  }
  
  return(G.Dat)
  
}

plotdat.G<-function(Data,Method){
  
  Data[,Order:=2*Superadditive.Pr+1.5*Additive.Pr+Averaging.Pr-2*Antagonistic.Pr]

  if(Method=="Ratios"){
  Data2<-melt.data.table(Data,id.vars = c("Practice","Outcome","N.Studies","N.Obs.Prac","Order",grep("_pc",colnames(Data),value=T),
                                          grep("Sig",colnames(Data),value=T),"Diff.Cat","Diff.Type"),variable.name = "Variable",value.name = "Value")
  
 
  
   Data2[,Out.SubInd:=factor(Outcome)]

   psymbol<-function(X){
     Y<-rep("ns",length(X))
     Y[X<=0.05]<-"*"
     Y[X<=0.01]<-"**"
     Y[X<=0.001]<-"***"
     return(Y)
   }
   
   Data2[Diff.Cat=="Superadditive",Plab:=psymbol(Superadditive.Sig)]
   Data2[Diff.Cat=="Additive",Plab:=psymbol(Additive.Sig)]
   Data2[Diff.Cat=="Averaging",Plab:=psymbol(Averaging.Sig)]
   Data2[Diff.Cat=="Antagonistic",Plab:=psymbol(Antagonistic.Sig)]

  
  # Rename columns
  setnames(Data2,"Variable","Interaction.Type")
  setnames(Data2,"Value","Proportion")
  
  Data2[,Interaction.Type:=gsub(".Pr","",Interaction.Type)]
  
  # Rename outcome subindicators so axis labels include the number of studies and observations
  Data2[,Pr.Lab:=paste0(N.Studies,"/",N.Obs.Prac)]
  Data2[,Sig.Lab:=factor(paste0(Diff.Cat," (",Plab,")"))]
  
  # Make Sure Interaction Type is correctly ordered
  Data.Cat<-Data2[Interaction.Type %in% c("Superadditive","Additive","Averaging","Antagonistic")]
  Data.Cat[Interaction.Type %in% c("Superadditive","Additive","Averaging"),Sig.Lab:=""]
  
  Data.Cat[,Interaction.Type:=factor(Interaction.Type,levels=c("Superadditive","Additive","Averaging","Antagonistic"))]
  
  Data.Type<-Data2[Interaction.Type %in% c("Positive","Negative","Divergent")]
  Data.Type[,Interaction.Type:=factor(Interaction.Type,levels=c("Positive","Negative","Divergent"))]

  }else{
    
  Data2<-melt.data.table(Data,id.vars = c("Practice","Outcome","N.Studies","N.Obs.Prac","Order","Diff.Cat","Diff.Type"),variable.name = "Variable",value.name = "Value")
  
  Data2[,Out.SubInd:=factor(Outcome)]

  # Rename columns
  setnames(Data2,"Variable","Interaction.Type")
  setnames(Data2,"Value","Proportion")
  
  Data2[,Interaction.Type:=gsub(".Pr","",Interaction.Type)]
  
  # Rename outcome subindicators so axis labels include the number of studies and observations
  Data2[,Pr.Lab:=paste0(N.Studies,"/",N.Obs.Prac)]

  # Make Sure Interaction Type is correctly ordered
 Data.Cat<-Data2[Interaction.Type %in% c("Superadditive","Additive","Averaging","Antagonistic")]
 Data.Cat[,Interaction.Type:=factor(Interaction.Type,levels=c("Superadditive","Additive","Averaging","Antagonistic"))
          ][,Proportion:=round(Proportion,5)]
  
  Data.Type<-Data2[Interaction.Type %in% c("Positive","Negative","Divergent")]
  Data.Type[,Interaction.Type:=factor(Interaction.Type,levels=c("Positive","Negative","Divergent"))]

  }
  
    return(list(Data.Cat=Data.Cat,Data.Type=Data.Type))

}

# Function to shorten practices names
ShortPNames<-function(Data,ColNameFrom,ColNameTo){
  
  setnames(Data,ColNameFrom,"Practice")
  
    Data[,Practice:=gsub("Mulch","Mulch Herb",Practice),by=Practice
         ][,Practice:=gsub("Agroforestry Pruning","Mulch Tree",Practice),by=Practice
           ][,Practice:=gsub("Agroforestry","AgroF.",Practice),by=Practice
             ][,Practice:=gsub("Crop Residue Incorporation","Res. Incorp.",Practice),by=Practice
              ][,Practice:=gsub("Fertilizer","Fert.",Practice),by=Practice
                ][,Practice:=gsub("Inorganic","Inorg.",Practice),by=Practice
                  ][,Practice:=gsub("Organic","Org.",Practice),by=Practice
                    ][,Practice:=gsub("Reduced Tillage","Red. Till.",Practice),by=Practice
                      ][,Practice:=gsub("Harvesting","Harvest",Practice),by=Practice
                        ][,Practice:=gsub("Alleycropping","Alleycrop",Practice),by=Practice
                          ][,Practice:=gsub("Improved Varieties","Imp. Var.",Practice),by=Practice
                            ][,Practice:=gsub("Improved Varieties","Imp. Var.",Practice),by=Practice
                              ][,Practice:=gsub("Intercropping","Intercrop",Practice),by=Practice
                                ][,Practice:=gsub("Crop Rotation","Rotation",Practice),by=Practice
                                  ][,Practice:=gsub("Supplemental Irrigation","Supp. Irrig.",Practice),by=Practice
                                    ][,Practice:=gsub("Green Manure","Green Man.",Practice),by=Practice]
    
  setnames(Data,"Practice",ColNameTo)
  return(Data)
    }


# Function to shorten practices names
ShortONames<-function(Data,ColNameFrom,ColNameTo){
  
  setnames(Data,ColNameFrom,"Outcome")
  
    Data[,Outcome:=gsub("Crop Yield","Yield",Outcome),by=Outcome
         ][,Outcome:=gsub("Soil Organic Carbon","SOC",Outcome),by=Outcome
           ][,Outcome:=gsub("Soil Nitrogen","Soil N",Outcome),by=Outcome
             ][,Outcome:=gsub("Water Use Efficiency","RUE",Outcome),by=Outcome
              ][,Outcome:=gsub("Gross Return","Gr.Return",Outcome),by=Outcome
                ][,Outcome:=gsub("Infiltration Rate","Infil.Rate",Outcome),by=Outcome
                  ][,Outcome:=gsub("Soil Moisture","Soil Moist.",Outcome),by=Outcome]
    
  setnames(Data,"Outcome",ColNameTo)
  return(Data)
    }

```

```{r Colocated - run analysis,echo=F}

G.Dat<-reactive({
  if(input$Colocated.Method=="Ratios"){
    ColocatedFun(Data= data.table::copy(ERA),
          rmOut=if(input$rmOut=="Yes"){T}else{F},
          PLevel=Prac.Levels[Choice %in% input$PLevel,list(Prac,Base)],
          OLevel=Out.Levels[Choice %in% input$OLevel,Out],
          RemoveInt=T,
          Min.Studies=1,
          Min.Obs=3,
          SaveDir="Colocated Ratios/")
  }else{
        ColocatedFun.Diff(Data= data.table::copy(ERA.Econ),
          PLevel=Prac.Levels[Choice %in% input$PLevel,list(Prac,Base)],
          OLevel=Out.Levels[Choice %in% input$OLevel,Out],
          RemoveInt=T,
          Min.Studies=1,
          Min.Obs=3,
          SaveDir="Colocated Diff/")
  }
})

Outcomes.Colocated<-reactive({G.Dat()$ClassSummary[N.Studies>=input$Min.Studies & N.Obs.Prac>=input$Min.Obs,unique(Outcome)]})

```

##### B1.1) Methods/Info
This analysis looks at interaction data from studies which contain two or more practices added to a control in combination and individually (i.e., `A+B vs Control`, `A vs Control`, and `B vs Control`). This is the gold standard of data quality as the effects of an interaction and its component practices are co-located and compared to the same control at the same time in the same place.  

For treatments with individual and combined practices to be compared within a study they must have identical management for base practices shared across all the experimental treatments. Where a management practice varies between individual and combined treatments because it is linked to a practice, e.g. the amount of inorganic nitrogen applied, this is allowed to differ. 
Where practice levels exist in the data, e.g. a factorial experiment of 0, 10, 20, 40, and 80 kg/ha mulch applied, and these levels are not capture in an ERA variable then outcome values are averaged across levels. Where treatments have different controls the control outcome value is averaged.  

As co-located data are from treatments within the same experiment, they are directly comparable and were classified using the difference, rather than ratio, of experimental and control treatments. 

The directionality of components (`C`) is classified in order of divergent (any `C>0` and any `C<0`), positive (all `C>=0`), negative (all `C<=0`), and zero (all `C=0`).  

Bundling results per observation (row) are classified by comparison of the bundle difference (`B`) versus `C` or `SC` using logic described below and illustrated in Figure 1 of the manuscript that accompanies this markdown. For antagonistic, averaging, and additive classes p-values and significance at P0.05 are derived from the maximum p-value of `B` vs `C` t-tests, the directionality of the alternative hypothesis depending on the class. For superadditive results the t-test for `B` vs `SC` are used to derive the p-value and if the directionality of `C` is divergent or negative, then `C` is substituted for `SC` when `SC<max(C)`. Classifications are as follows:  
1.	Antagonistic: `B <min(C)`. Alt. hypothesis = lower.  
2.	Averaging: `Bmin(C)` and `Bmax(C)`. Alt. hypothesis = lower when `B<Cn`, higher when `B>Cn`.  
3.	Additive: `B>max(C)` and `BSC`. Alt. hypothesis = higher.  
4.	Superadditive: `B>max(C)` and `B>SC`. Alt. hypothesis = higher.  

The proportion of each class across all observations of a bundle and outcome combinations are presented in Section B1.2 There is no exclusion of outliers (these cannot be detected across studies or crops) or outcomes that have divergent signs for experiment vs control outcome values. 

##### B1.2) Bar Plot
```{r Colocated - choose outcome,echo=F}

  # Choose which outcomes to include or exclude in the analysis
  renderUI(checkboxGroupInput("Colocated.Outcomes", "Choose outcomes: ",choices = Outcomes.Colocated(), selected=Outcomes.Colocated(), inline=T))

```


:::: {style="display: flex;"}
::: {}
```{r Colocated - Bar Plot Simple Facet Text Wrapping, echo=F}
numericInput(inputId="Colocated.Bar.FacetLabWidth",
             label="Adjust facet wrapping",
             value=30,
             min=5,
             max=60,
             step=1,
             width="180px")
```
:::
::: {}
```{r Colocated - Bar Plot Simple Panel Spacing, echo=F}
numericInput(inputId="Colocated.Bar.Panel.Space",
             label="Adjust panel spacing",
             value=0.1,
             min=0,
             max=5,
             step=0.05,
             width="180px")
```
:::
::: {}
```{r Colocated- Bar show labels, echo=F}
selectInput(inputId="Colocated.Bar.ShowLabel",
            label="Show data availability?", 
            choices = c("Yes","No"), 
            selected = "Yes", 
            multiple =  F,
            width="180px")
```
:::
:::{}
```{r Colocated - Bar Shadow}
  selectInput(inputId="Colocated.Bar.Shadow", 
              label="Shadow labels?",
              choices = c("Yes","No"),
              selected="Yes", 
              multiple = F,
              width="150px")
```
:::
:::{}
```{r Colocated - Bar Barwidth,eval=T}
      numericInput(inputId = "Colocated.Bar.Barwidth",
                   label = "Bar width",
                   value = 1,
                   min = 0,
                   max = 10,
                   step = 0.1,
                   width="100px")  
```
:::
::: {}
```{r Colocated - YAxis}
  selectInput(inputId="Colocated.Bar.YAxis", 
              label="Y-axis variable",
              choices = c("Practice","Outcome"),
              selected="Practice", 
              multiple = F,
              width="150px")
```
:::
:::{}
```{r Colocated - Bar Simple Colour Picker}
 colourInput(inputId="Colocated.Bar.Col",
             label="Select colour", 
             value="#030303")
```
:::
::::

:::: {style="display: flex;"}
::: {}
```{r Colocated - Bar Save Plot}
  selectInput(inputId="Colocated.Bar.Save.Plot", 
              label="Save plot?",
              choices = c("Yes","No"),
              selected="No", 
              multiple = F,
              width="200px")
```
:::
:::{}
```{r Colocated -Bar Filename, echo=F}
    textInput(inputId="Colocated.Bar.Filename",
              label="Enter file name", 
              value="Enter text",
              width="200px")
            
```
:::
::::

```{r Colocated - prepare plot data, echo = F}

PDat<-reactive({
  plotdat.G(
  Data=data.table::copy(G.Dat()$ClassSummary)[N.Studies>=input$Min.Studies & N.Obs.Prac>=input$Min.Obs & Outcome %in% input$Colocated.Outcomes],
  Method=input$Colocated.Method
  )
  })

```

```{r Colocated - create bar height and width functions}
  Colocated.Bar.Height <- function(){
           20*input$BP.Plot.Height*nrow(unique(PDat()$Data.Cat[,list(Practice,Outcome)]))
  }

  Colocated.Bar.Width <- function(){
           900*input$BP.Plot.Width
        }
```

**Summary of data available given minimum data requirements, outcome and practice selections**
```{r Colocated - summary text}

renderText({
  paste0("This analysis contains ", PDat()$Data.Cat[,length(unique(Practice))], " interactions of ", PDat()$Data.Cat[,length(unique(unlist(strsplit(Practice,"-"))))]," ", input$PLevel,"s.")
})

renderText({
        paste0("There are a total of ", PDat()$Data.Cat[,length(unique(paste(Practice,Outcome)))]," ",input$PLevel," x Outcome ",input$PLevel, " combinations for ", PDat()$Data.Cat[,length(unique(Outcome))]," Outcome ", input$OLevel,"s.")
})

```

```{r Colocated - make bar plot, echo = F}

ColocatedBarPlotFun<-function(Data,
                         ShowLabs,
                         OutlineColour,
                         TextWrapWidth,
                         PanelSpace,
                         FontSize,
                         ShadowLabs,
                         Barwidth,
                         Palette,
                         ShortNames,
                         Yaxis){
  
   if(ShortNames=="Yes"){
     Data<-ShortPNames(Data,"Practice","Practice")
   }
  
  Data[Outcome=="Water Use Efficiency",Outcome:="Rainfall Use Efficiency"]
   
  
  Data[,Practice:=gsub("-"," + ",Practice),by=Practice]
     
  
  if(Yaxis=="Practice"){
      if(ShowLabs=="Yes"){
        gBarplot<-ggplot(Data,aes(x = reorder(Practice,Order), y = Proportion,fill=Interaction.Type,label=Pr.Lab))
      }else{
        gBarplot<-ggplot(Data,aes(x = reorder(Practice,Order), y = Proportion,fill=Interaction.Type))
      }
  
      gBarplot<-gBarplot+
      facet_grid(Outcome~.,drop=T,scales = "free_y", labeller = label_wrap_gen(width=TextWrapWidth), space="free_y")+
      labs(x =NULL, y = "Proportion")
  
  }else{
    
    Data[,Outcome:=factor(Outcome,sort(unique(Outcome),decreasing = T))]
    
     if(ShowLabs=="Yes"){
        gBarplot<-ggplot(Data,aes(x = Outcome, y = Proportion,fill=Interaction.Type,label=Pr.Lab))
      }else{
        gBarplot<-ggplot(Data,aes(x = Outcome, y = Proportion,fill=Interaction.Type))
      }
    
    gBarplot<-gBarplot+
      facet_grid(Practice~.,drop=T,scales = "free_y", labeller = label_wrap_gen(width=TextWrapWidth), space="free_y")+
      labs(x =NULL, y = "Proportion")
  }
      
    gBarplot<-gBarplot + 
      geom_bar(stat = "identity",size=0.25, colour=OutlineColour,width=Barwidth)+
      scale_fill_manual("Interaction\nType",values=Palette)+
      scale_y_continuous(expand = expansion(add=c(-0.0001,0.0001)))+
      coord_flip(ylim=c(0.0001,1))+
      theme_bw()+ 
            theme(panel.grid.major = element_blank(),
            panel.grid.minor = element_blank(),
            panel.background = element_blank(),
            panel.border = element_blank(),
            plot.background = element_rect(fill = "transparent"),
            axis.ticks = element_blank(),
            legend.background = element_rect(colour = "transparent", fill = "transparent"),
            legend.position = "bottom",
            axis.title =  element_blank(),
            strip.text.y = element_text(angle=0,face="bold",hjust=0),
            strip.background = element_blank(),
            panel.spacing = unit(PanelSpace, "lines"),
            plot.margin=unit(c(0,5,0,0),"mm"),
            text = element_text(size=FontSize))+
      guides(fill=guide_legend(override.aes = list(pattern="none")),pattern=guide_legend(override.aes = list(fill="black")))
    
    if(ShowLabs=="Yes"){
      if(ShadowLabs=="Yes"){
         gBarplot<-gBarplot+shadowtext::geom_shadowtext(aes(y=0.01), hjust=0, colour="black",bg.colour="white", check_overlap = TRUE)
      }else{
         gBarplot<-gBarplot+geom_text(aes(y=0.01),hjust=0, check_overlap = TRUE)
      }}
            
    return(gBarplot)
    
}


ColocatedBarPlot<-reactive({
  ColocatedBarPlotFun(Data=data.table::copy(PDat()$Data.Cat),
                 ShowLabs=input$Colocated.Bar.ShowLabel,
                 OutlineColour=input$Colocated.Bar.Col,
                 TextWrapWidth=input$Colocated.Bar.FacetLabWidth,
                 Barwidth=input$Colocated.Bar.Barwidth,
                 PanelSpace=input$Colocated.Bar.Panel.Space,
                 FontSize=input$BP.Global.Font.Size,
                 ShadowLabs=input$Colocated.Bar.Shadow,
                 Palette = viridisLite::viridis(4, begin = 0,end = 1,alpha=0.5,option=input$BP.Palette),
                 ShortNames = input$BP.Bar.ShortNames,
                 Yaxis=input$Colocated.Bar.YAxis)

})

```

```{r Colocated - render bar plot, echo = F}

renderPlot({ColocatedBarPlot()},height=Colocated.Bar.Height,width=Colocated.Bar.Width)

```

```{r Colocated - Save Bar Plot,echo = F}

reactive({
  if(input$Colocated.Bar.Save.Plot=="Yes"){
   if(input$Colocated.Bar.Filename != "Enter text here"){
    if(input$BP.Save.Format=="pdf"){
    ggsave(filename = paste0(input$Colocated.Bar.Filename,".",input$BP.Save.Format),
           plot = ColocatedBarPlot(),
           path = "./Plots",
           width= input$BP.Save.Width,
           height = input$BP.Save.Height,
           units = "mm",
           scale = input$BP.Save.Scale,
           dpi = input$BP.Save.Resolution,
           device = cairo_pdf)
    }else{
          ggsave(filename = paste0(input$Colocated.Bar.Filename,".",input$BP.Save.Format),
           plot = ColocatedBarPlot(),
           path = "./Plots",
           width= input$BP.Save.Width,
           height = input$BP.Save.Height,
           units = "mm",
           scale = input$BP.Save.Scale,
           dpi = input$BP.Save.Resolution,
           type = "cairo")
    }}}})


```

##### B1.3) Data Table

```{r Colocated - render table, echo = F}
  renderDT({
      datatable(PDat()$Data.Cat[,!"Order"][Outcome=="Water Use Efficiency",Outcome:="Rainfall Use Efficiency"],
                caption="Colocated standard data",
                extensions = 'Buttons',
                filter = "top",
                options = list(dom = 'Blfrtip',
                               buttons = c('copy', 'csv', 'excel', 'pdf', 'print'),
                               lengthMenu = list(c(10,25,50,-1),c(10,25,50,"All"))))
      
    })

```

##### B1.4) Bibliography

```{r Colocated - Bibliographic Data}

Colocated.Bib.Data<-reactive({
    unique(G.Dat()$Class[,PxO:=paste0(Interaction,"-",Outcome)
                ][PxO %in% PDat()$Data.Cat[,unique(paste0(Practice,"-",Outcome))],list(Outcome,Interaction,Code)])
})

Colocated.Bib.Data2<-reactive({
  data.table(Colocated.Bib.Data(),ERA_Bibliography[match(Colocated.Bib.Data()[,Code],ERACODE), list(AUTHOR,JOURNAL,YEAR,VOLUME,NUMBER,PAGES,TITLE,TYPE,DOI)])
})

```

```{r Colocated - Bibliographic Table}

  renderDT({
      datatable(Colocated.Bib.Data2(),
                caption="Bibliography",
                extensions = 'Buttons',
                filter = "top",
                options = list(dom = 'Blfrtip',
                               buttons = c('copy', 'csv', 'excel', 'pdf', 'print'),
                               lengthMenu = list(c(10,25,50,-1),c(10,25,50,"All"))))
      
    })
```

#### B2) Resampling Method {.tabset .tabset-fade .tabset-pills}
*As resampling can take a long time before enabling the analysis make sure you are happy with the default parameter settings for minimum data requirements and outlier removal. These can be changed above.*  

*We have supplied a pre-analysed datasets using 10,000 reps using the default parameters in this markdown and with outliers retained or removed.*

*The `Resampling length statistic` option below set the sample size for each sample based on the minimum or maximum number of observations for the practice interaction (bundle) and it's components. If the number of observations (n) of crop yield for interaction `A+B` is 20, for component `A` is 12, and for component `B` is 19 then the sampling length for each dataset is 12 when `Min` is selected and 20 when `Max` is selected.*

```{r Boot - create function, echo=F,eval=T}
# Function to resample pooled data and calculate interaction statistics
BootSynergies<-function(Data,rmOut,Min.Studies,Min.Obs,RemoveInt,Reps,cores,ROUND,PLevel,OLevel,SaveDir,SampleLength){
  
  BootFile<-paste0("Boot-",PLevel,"-",OLevel,"-",rmOut,"-",Min.Studies,"-",Min.Obs,"-",RemoveInt,"-",Reps,"-",SampleLength,".RData")
  
  if(!is.na(SaveDir)){
    if(substr(SaveDir,nchar(SaveDir),nchar(SaveDir))!="/"){
      SaveDir<-paste0(SaveDir,"/")
    }
    
    if(!dir.exists(SaveDir)){
      dir.create(SaveDir,recursive=T)
    }
  }
  
  
  if(file.exists(paste0(SaveDir,BootFile))){
    Boot.Out<-miceadds::load.Rdata2(BootFile,path=SaveDir)
  }else{
    
    # Generate all components of an interaction
    GenCombo<-function(Name,Delim){
      NPracs<-str_count(Name[1],Delim)+1
      Pracs<-unlist(lapply(1:NPracs,FUN=function(j){
        combn(unlist(strsplit(Name,Delim)),m=j,FUN=paste,collapse=Delim)
      }))
      return(Pracs)
    }
    
    # Create a simple function to detect extreme outliers ####
    Out.Calc<-function(Vals){
      return((Vals < quantile(Vals)[2] - 3 *  IQR(Vals)  | Vals > quantile(Vals)[4] + 3 * IQR(Vals)))
    }
    
    # Rename columns ####
    if("PrName" !=PLevel){
      setnames(Data,"PrName","PrNameX")
      setnames(Data,"PrName.Base","PrName.BaseX")
      
      setnames(Data,PLevel,"PrName")
      setnames(Data,paste0(PLevel,".Base"),"PrName.Base")
    }
    
    if("Out.SubInd" != OLevel){
      setnames(Data,"Out.SubInd","Out.SubIndX")
      setnames(Data,OLevel,"Out.SubInd")
    }
    
    
    # Make sure practices are ordered alphabetically ####
    FunB<-function(X){
      Z<-unlist(strsplit(X,"-"))
      paste(Z[order(Z)],collapse="-")
    }
    
    Data[,PrName:=FunB(PrName[1]),by=PrName]
    Data[,PrName.Base:=FunB(PrName.Base[1]),by=PrName.Base]
    
    # Remove practices that contain NA practices ####
    Data<-Data[!grepl("NA",PrName)]
    
    # Remove Outliers? ####
    Aggregate.By<-c("PrName","Out.SubInd")
    
    if(rmOut){
      Outliers<-unlist(Data[,R:=1:nrow(Data)
      ][,list(Outliers=list(R[Out.Calc(yi)])), by=Aggregate.By
      ][,Outliers])
      
      Data<-Data[!Outliers]
    }
    
    # Add Weights ####
    Weight.Group<-unique(c("Code",Aggregate.By))
    
    Data[,N.Obs.Study:=.N,by=Weight.Group # Recalculate Weightings by study within observations grouping 
    ][,Weight.Study:=(Rep^2/(2*Rep))/N.Obs.Study # Recalculate Weightings
    ][,N.Studies:=length(unique(Code)),by=Aggregate.By
    ][,N.Obs.Prac:=.N,by=Aggregate.By]
    
    
    # Subset interactions to those that meet minimum data requirements ####
    
    Combinations<-Data[grep("-",PrName),list(NPracs=str_count(PrName[1],"-")+1),by=Aggregate.By]
    
    FunC<-function(PrName,OUTCOME,RemoveInt){
      Pracs<-GenCombo(Name=PrName,Delim="-")
      if(RemoveInt){
        Pracs<-c(PrName,Pracs[!grepl("-",Pracs)])
      }
      
      all(Pracs %in% Data[N.Studies>= Min.Studies & N.Obs.Prac>=Min.Obs & Out.SubInd==OUTCOME,unique(PrName)])
    }
    
    # RemoveInt=T removes any interactions from component practices, RemoveInt = F retains interactions among components
    Combinations<-Combinations[,DataPresent:=FunC(PrName[1],Out.SubInd[1],RemoveInt = RemoveInt),by=Aggregate.By]
    Combinations<-Combinations[DataPresent==T]
    
    # Report products by combination x interaction ####
    Combinations[,PxO:=paste(PrName,Out.SubInd,collapse=" "),by=list(PrName,Out.SubInd)]
    Data[,PxO:=paste(PrName,Out.SubInd,collapse=" "),by=list(PrName,Out.SubInd)]
    
    Combo.Products<-Data[PxO %in% Combinations[,PxO],list(PrName,Out.SubInd,Code,Product.Simple)
    ][,Index:=1:.N
    ][Product.Simple=="",Product.Simple:="Unknown"
      ][,Min.Studies:=length(unique(Code)),by=list(PrName,Out.SubInd)]
    
    # Split products
    Products<-Combo.Products[,unlist(strsplit(Product.Simple,"-"))]
    Combo.Products<-Combo.Products[rep(Combo.Products[,Index],Combo.Products[,str_count(Product.Simple,"-")+1])
                                   ][,Product.Simple:=Products
                                     ][,Index:=NULL
                                       ][,Type:="Combination"
                                         ][Product.Simple=="",Product.Simple:="Unknown"]
    
    setnames(Combo.Products,"PrName","Combination")
    
    
    Comp.Products<-rbindlist(lapply(1:nrow(Combinations),FUN=function(i){
      
      PRAC<-Combinations[i,PrName]
      OUT<-Combinations[i,Out.SubInd]
      
      A<-Data[PrName %in% unlist(strsplit(PRAC,"-")) & Out.SubInd %in% OUT,list(PrName,Out.SubInd,Code,Product.Simple)
              ][,Min.Studies:=min(length(unique(Code))),by=PrName
                ][,Min.Studies:=min(Min.Studies)
                  ][,PrName:=PRAC
                    ][,Index:=1:.N
                      ][Product.Simple=="",Product.Simple:="Unknown"]
      
      # Split products
      Products<-A[,unlist(strsplit(Product.Simple,"-"))]
      A<-A[rep(A[,Index],A[,str_count(Product.Simple,"-")+1])
           ][,Product.Simple:=Products
             ][,Index:=NULL
               ][,Type:="Component"]
      
      setnames(A,"PrName","Combination")
      
      A
      
    }))
    
    Combo.Products<-rbind(Combo.Products,Comp.Products)[,Concept:="Product"]
    Combo.Products[,Product.Subtype:=EUCodes[match(Combo.Products[,Product.Simple],Product.Simple),Product.Subtype]
                   ][is.na(Product.Subtype),Product.Subtype:="Unknown"
                     ][,Min.Studies:=min(Min.Studies),by=list(Combination,Out.SubInd)]
    
    # Report base practices by combination x interaction ####
    
    Combo.Base<-Data[PxO %in% Combinations[,PxO],list(PrName,Out.SubInd,Code,PrName.Base)
    ][,Index:=1:.N
    ][PrName.Base=="",PrName.Base:="None"
      ][,Min.Studies:=length(unique(Code)),by=list(PrName,Out.SubInd)]
    
    BasePracs<-Combo.Base[,unlist(strsplit(PrName.Base,"-"))]
    Combo.Base<-Combo.Base[rep(Combo.Base[,Index],Combo.Base[,str_count(PrName.Base,"-")+1])
                           ][,PrName.Base:=BasePracs
                             ][,Index:=NULL
                               ][,Type:="Combination"
                                 ][PrName.Base=="",PrName.Base:="None"]
    setnames(Combo.Base,"PrName","Combination")
    
    
    Comp.Base<-rbindlist(lapply(1:nrow(Combinations),FUN=function(i){
      
      PRAC<-Combinations[i,PrName]
      OUT<-Combinations[i,Out.SubInd]
      
      A<-Data[PrName %in% unlist(strsplit(PRAC,"-")) & Out.SubInd %in% OUT,list(PrName,Out.SubInd,Code,PrName.Base)
              ][,Min.Studies:=min(length(unique(Code))),by=PrName
                ][,Min.Studies:=min(Min.Studies)
                  ][,PrName:=PRAC
                    ][,Index:=1:.N
                      ][PrName.Base=="",PrName.Base:="None"]
      
      # Split products
      BasePracs<-A[,unlist(strsplit(PrName.Base,"-"))]
      A<-A[rep(A[,Index],A[,str_count(PrName.Base,"-")+1])
      ][,PrName.Base:=BasePracs
      ][,Index:=NULL
      ][,Type:="Component"]
      
      setnames(A,"PrName","Combination")
      
      A
      
    }))
    
    Combo.Base<-rbind(Combo.Base,Comp.Base)[,Concept:="Practice"]
    Combo.Base[,Theme.Base:=PracticeCodes[match(Combo.Base[,PrName.Base],Practice),Theme]
               ][is.na(Theme.Base),Theme.Base:="None"
                 ][,Min.Studies:=min(Min.Studies),by=list(Combination,Out.SubInd)]
    
    
    # List all practices required by outcomes ####
    All.PrNames<-lapply(Combinations[,unique(Out.SubInd)],FUN = function(OUT){
      unique(unlist(lapply(Combinations[Out.SubInd==OUT,PrName],FUN=function(PRAC){
        NPracs<-str_count(PRAC[1],"-")+1
        Pracs<-unlist(lapply(1:NPracs,FUN=function(j){
          combn(unlist(strsplit(PRAC,"-")),m=j,FUN=paste,collapse="-")
        }))
        if(RemoveInt){
          Pracs<-c(PRAC,Pracs[!grepl("-",Pracs)])
        }
        Pracs
        
      })))
    })
    names(All.PrNames)<-Combinations[,unique(Out.SubInd)]
    
    # Bootstrap Outcomes x Practices ####
    
    # Display progress
    cat('\r                                                                                                                                    ')
    cat('\r',paste("Bootstrapping Practices by Outcome (this might take a while)\n"))
    # Create function for use in bootstrapping
    
    cl<-makeCluster(cores)
    clusterEvalQ(cl, list(library(data.table),library(stringr),library(weights)))
    clusterExport(cl,list("GenCombo","Data","Combinations","Reps"),envir=environment())
    registerDoSNOW(cl)
    
    Boot.Data<-rbindlist(parLapply(cl,1:nrow(Combinations),fun=function(k){
      
      # Boot.Data<-rbindlist(pblapply(1:nrow(Combinations),FUN=function(k){
      
      INT<-unique(Combinations[,list(PrName,Out.SubInd)])[k,PrName]
      OUT<-unique(Combinations[,list(PrName,Out.SubInd)])[k,Out.SubInd]
      PRACS<-GenCombo(INT,Delim="-")
      PRACS<-PRACS[!grepl("-",PRACS)]
      
      Components<-Data[PrName %in% PRACS & Out.SubInd == OUT,list(PrName,pc,Weight.Study)]
      Components<-split(Components,f=Components[,PrName])
      Interaction<-Data[PrName == INT & Out.SubInd == OUT,list(pc,Weight.Study)]
      
      MAX<-max(c(unlist(lapply(Components,nrow)),nrow(Interaction)))
      MIN<-min(c(unlist(lapply(Components,nrow)),nrow(Interaction)))
      
      Z<-lapply(1:Reps,FUN=function(i){
        
        X<-lapply(Components,FUN=function(Y){
          Y[sample(1:nrow(Y),if(SampleLength=="Max"){MAX}else{MIN},replace = T),list(pc,Weight.Study)
          ][,Weight.Study:=Weight.Study/sum(Weight.Study)
          ][,W.Mean:=pc*Weight.Study
          ]
        })
        
        PC<-rowSums(do.call("cbind",lapply(X,"[[","W.Mean")))
        PC<-PC*length(PC)
        Weights<-rep(1,length(PC))
        
        X[["Summed"]]<-data.table(pc=PC,Weight.Study=Weights)
        
        N<-sample(1:nrow(Interaction),if(SampleLength=="Max"){MAX}else{MIN},replace = T)
        
        X[["Int"]]<-data.table(pc=Interaction[N,pc],Weight.Study=Interaction[N,Weight.Study])
        X
        
      })
      
      Z<-rbindlist(lapply(1:length(Z),FUN=function(i){
        X<-Z[[i]]
        INT<-X[["Int"]]
        X["Int"]<-NULL
        Y<-lapply(X,FUN=function(Y){
          suppressWarnings(A<-wtd.t.test(x=INT[,pc],y=Y[,pc],weight=INT[,Weight.Study],weighty=Y[,Weight.Study],alternative="greater"))
          suppressWarnings(B<-wtd.t.test(x=INT[,pc],y=Y[,pc],weight=INT[,Weight.Study],weighty=Y[,Weight.Study],alternative="less"))
          rbind(
            data.table(direction="Greater",t(data.frame(A$coefficients)),t(data.frame(A$additional))),
            data.table(direction="Less",t(data.frame(B$coefficients)),t(data.frame(B$additional)))
          )
        })
        data.table(rbindlist(Y),Component=rep(names(Y),each=2))[,Rep:=i]
      }))[,Out.SubInd:=OUT][,PrName:=INT]
      
      Z
      
      
    }))
    
    stopCluster(cl)
    
    # Extract bootstrapped means from boot objects ####
    # x = interaction
    # y = component
    
    Boot.Data<-dcast(Boot.Data,Rep+PrName+Component+Out.SubInd+Mean.x+Mean.y+`Std. Err`+t.value+df+Difference+Out.SubInd~direction,value.var =   "p.value")
    setnames(Boot.Data,"Std. Err","SE")
    
    
    # Classify interactions ####
    
    # Display progress
    cat('\r                                                                                                                                    ')
    cat('\r',paste("Classifying Synergies from Bootstrap Data\n"))
    
    cl<-makeCluster(cores)
    clusterEvalQ(cl, list(library(data.table),library(stringr)))
    clusterExport(cl,list("GenCombo","Boot.Data","Combinations","RemoveInt"),envir=environment())
    registerDoSNOW(cl)
    
    BootClass<-parLapply(cl,1:nrow(Combinations),fun=function(i){
      #BootClass<-pblapply(1:nrow(Combinations),FUN=function(i){
      options(scipen=999)
      
      OUT<-Combinations[i,Out.SubInd]
      INT<-Combinations[i,PrName]
      PRACS<-GenCombo(INT,"-")
      if(RemoveInt){
        PRACS<-c(INT,PRACS[!grepl("-",PRACS)])
      }
      
      COMP<-PRACS[PRACS!=INT] 
      PRACS<-c(INT,COMP) # Ensure correct order of interaction and components
      
      X<-Boot.Data[PrName==INT & Out.SubInd==OUT]
      
      X<-dcast(X,formula=Mean.x+Out.SubInd+PrName+Rep~Component,value.var = c("Mean.y","Difference","SE","Greater","Less"),fun.aggregate = mean)
      
      setnames(X,"Mean.x","pc_Int")
      setnames(X,"Mean.y_Summed","pc_sum")  
      
      
      COMP.PC<-paste0("Mean.y_",COMP)
      COMP.LESS.s<-paste0("Less_",COMP)
      COMP.GTR.s<-paste0("Greater_",COMP)
      
      suppressWarnings(X[,Greater_Max:=unlist(lapply(1:nrow(X),FUN=function(i){
        unlist(X[i,..COMP.GTR.s])[unlist(X[i,..COMP.PC]==max(X[i,..COMP.PC]))]
      }))])
      
      
      # Determine directionality of component scores ####
      X[,Diff.Type.pc:=as.character(NA)]
      
      X[,Diff.Type.pc:="Divergent"]
      X[apply(X[,..COMP.PC],1,FUN=function(Y){all(Y>=0)}),Diff.Type.pc:="Positive"]
      X[apply(X[,..COMP.PC],1,FUN=function(Y){all(Y<=0)}),Diff.Type.pc:="Negative"]
      X[apply(X[,..COMP.PC],1,FUN=function(Y){all(Y==0)}),Diff.Type.pc:="Zero"]
      suppressWarnings(X[,pc_max:=apply(X[,..COMP.PC],1,max)])
      suppressWarnings(X[,pc_min:=apply(X[,..COMP.PC],1,min)])
      
      # pc_max_div - for divergent practices which is higher the max or the sum of the components (for n>2 practices) ####
      X[,N:=1:.N][,pc_max_div:=max(pc_max,pc_sum),by=N][,N:=NULL]
      X[,N:=1:.N][,Greater_Max_Div:=max(Greater_Max,Greater_Summed),by=N]
      
      # Classify Interactions #####
      X[,Diff.Cat.pc:=as.character(NA)]
      
      # Antagonistic
      X[pc_Int<pc_min,Diff.Cat.pc:="Antagonistic"] # Int<(A|B) same no matter what the difference type
      suppressWarnings(X[,Antagonistic.Sig:=apply(X[,..COMP.LESS.s],1,max)])
      
      # Averaging
      X[pc_Int>=pc_min & pc_Int<=pc_max,Diff.Cat.pc:="Averaging"] 
      
      # Choose sub component significance based on direction of difference and take the max significance of the all subcomponents
      Z<-X[Diff.Cat.pc=="Averaging",pc_Int]<X[Diff.Cat.pc=="Averaging",..COMP.PC]
      suppressWarnings(X[Diff.Cat.pc=="Averaging",Averaging.Sig:=apply(pmax(Z*X[Diff.Cat.pc=="Averaging",..COMP.LESS.s],(!Z)*X[Diff.Cat.pc=="Averaging",..COMP.GTR.s]),1,max)])
      
      # Positive Component Scores
      #Int<=(A+B) & Int>max(A|B)
      X[pc_Int<=pc_sum & pc_Int>pc_max & Diff.Type.pc %in% c("Positive","Zero"),Diff.Cat.pc:="Additive"]
      X[Diff.Type.pc %in% c("Positive","Zero"),Additive.Sig:=Greater_Max]
      
      # Int>(A+B)
      X[pc_Int>=pc_sum & Diff.Type.pc %in% c("Positive","Zero"),Diff.Cat.pc:="Superadditive"]
      X[Diff.Type.pc %in% c("Positive","Zero"),Superadditive.Sig:=Greater_Summed]
      
      # Divergent & Negative Component Scores
      if(any(X[,Diff.Type.pc] %in%  c("Divergent","Negative"))){
        X[pc_Int>pc_max_div & Diff.Type.pc %in% c("Divergent","Negative"),Diff.Cat.pc:="Superadditive"] 
        Z<-rowSums(X[Diff.Type.pc %in% c("Divergent","Negative"),list(Greater_Summed,Greater_Max)] * matrix(X[Diff.Type.pc %in% c("Divergent","Negative"),c(pc_sum,pc_max)==max(pc_sum,pc_max),by=N][,V1],ncol = 2,byrow = T))
        X[Diff.Type.pc %in% c("Divergent","Negative"),Superadditive.Sig:=Z]
        
        X[pc_Int<pc_max_div & pc_Int>pc_max & Diff.Type.pc %in% c("Divergent","Negative"),Diff.Cat.pc:="Additive"] 
        X[pc_Int<pc_max_div & pc_Int>pc_max & Diff.Type.pc %in% c("Divergent","Negative"),Additive.Sig:=Greater_Max] 
      }
      
      # Ratio of interaction (Int) to sum of components 
      X[,Ratio.sum:=pc_Int/pc_sum]
      # Ratio of interaction (int) to highest of max component or sum of components
      X[,Ratio.max:=pc_Int/pc_max_div]
      X[,Out.SubInd:=OUT][,PrName:=INT]
      
      
    })
    
    stopCluster(cl)
    
    BootClass<- pblapply(BootClass,FUN=function(X){
      cols<-colnames(X)[unlist(lapply(X,class))=="numeric"]
      X[,(cols) := round(.SD,ROUND), .SDcols=cols]
      X
    })
    
    cols<-colnames(Boot.Data)[unlist(lapply(Boot.Data,class))=="numeric"]
    Boot.Data[,(cols) := round(.SD,ROUND), .SDcols=cols]
    
    
    # Create summary table
    # Display progress
    cat('\r                                                                                                                                    ')
    cat('\r',paste("Summarising Results\n")) 
    
    cl<-makeCluster(cores)
    clusterEvalQ(cl, list(library(data.table),library(stringr)))
    clusterExport(cl,list("BootClass","RemoveInt","GenCombo","Data"),envir=environment())
    registerDoSNOW(cl)
    
    ClassSummary<-parLapply(cl,1:length(BootClass),fun = function(i){
      #ClassSummary<-rbindlist(pblapply(1:length(BootClass),FUN=function(i){
      X<-data.table::copy(BootClass[[i]])
      
      # Means of components  
      cols<-grep("Mean.y",colnames(X),value = T)
      Y<-X[,..cols]
      
      cols<-paste0(gsub("Mean.y_","",colnames(Y)),"_pc.mean")
      Y1<-t(data.table(apply(Y,2,mean)))
      colnames(Y1)<-cols
      
      # Differences with components
      cols<-grep("Difference",colnames(X),value = T)
      cols<-cols[!grepl("Summed",cols)]
      Y<-X[,..cols]
      
      cols<-paste0(gsub("Difference_","",colnames(Y)),"_pc.diff.mean")
      Y2<-t(data.table(apply(Y,2,mean)))
      colnames(Y2)<-cols
      
      # SE of differences
      cols<-grep("SE",colnames(X),value = T)
      cols<-cols[!grepl("Summed",cols)]
      Y<-X[,..cols]
      
      cols<-paste0(gsub("SE_","",colnames(Y)),"_pc.diff.se")
      Y3<-t(data.table(apply(Y,2,mean)))
      colnames(Y3)<-cols
      
      PRACTICE<-X[1,PrName]
      PRACS<-GenCombo(PRACTICE,"-")
      if(RemoveInt){
        PRACS<-c(PRACTICE,PRACS[!grepl("-",PRACS)])
      }
      OUTCOME<-X[1,Out.SubInd]
      
      Y4<-unique(Data[Out.SubInd==OUTCOME & PrName %in% PRACS,list(PrName,N.Studies,N.Obs.Prac)])
      Y4<-Y4[match(PRACS,Y4[,PrName])]
      Y4<-data.table(N.Studies=Y4[,paste(N.Studies,collapse="/")],N.Obs.Prac=Y4[,paste(N.Obs.Prac,collapse="/")])
      
      data.table(
        PrName=PRACS[1],
        Out.SubInd=OUTCOME,
        Y4,
        Int_pc.mean = X[,mean(pc_Int)],
        Y1, Y2, Y3,
        SumComps_pc.mean = X[,mean(pc_sum)],
        
        Superadditive.Pr = X[,sum(Diff.Cat.pc=="Superadditive")/.N],
        Additive.Pr = X[,sum(Diff.Cat.pc=="Additive")/.N],
        Averaging.Pr = X[,sum(Diff.Cat.pc=="Averaging")/.N],
        Antagonistic.Pr = X[,sum(Diff.Cat.pc=="Antagonistic")/.N],
        
        Superadditive.Mean.Sig = X[Diff.Cat.pc=="Superadditive",mean(Superadditive.Sig)],
        Additive.Mean.Sig = X[Diff.Cat.pc=="Additive",mean(Additive.Sig)],
        Averaging.Mean.Sig = X[Diff.Cat.pc=="Averaging",mean(Averaging.Sig)],
        Antagonistic.Mean.Sig = X[Diff.Cat.pc=="Antagonistic",mean(Antagonistic.Sig)],
        
        
        Superadditive.Pr.Sig.Tot=X[,sum(Superadditive.Sig<=0.05)/.N],
        Superadditive.Pr.Sig.SubAdd.Tot=X[Diff.Cat.pc=="Superadditive",sum(Superadditive.Sig<=0.05)/.N],
        Additive.Pr.Sig.Tot=X[,sum(Additive.Sig<=0.05)/.N],
        Averaging.Pr.Sig.Tot=X[,sum(Averaging.Sig<=0.05,na.rm=T)/.N],
        Averaging.Pr.Sig.Tot.NA = X[,sum(is.na(Averaging.Sig))/.N],
        Antagonistic.Pr.Sig.Tot=X[,sum(Antagonistic.Sig<=0.05)/.N],
        
        Superadditive.Pr.Sig = X[Diff.Cat.pc=="Superadditive",sum(Superadditive.Sig<=0.05)/.N],
        Superadditive.Pr.Sig.SubAdd = X[Diff.Cat.pc=="Superadditive",sum(Additive.Sig<=0.05)/.N],
        Additive.Pr.Sig = X[Diff.Cat.pc=="Additive",sum(Additive.Sig<=0.05)/.N],
        Averaging.Pr.Sig = X[Diff.Cat.pc=="Averaging",sum(Averaging.Sig<=0.05)/.N],
        Antagonistic.Pr.Sig = X[Diff.Cat.pc=="Antagonistic",sum(Antagonistic.Sig<=0.05)/.N],
        
        Positive.Pr=X[,sum(Diff.Type.pc=="Positive")/.N],
        Divergent.Pr=X[,sum(Diff.Type.pc=="Divergent")/.N],
        Negative.Pr=X[,sum(Diff.Type.pc=="Negative")/.N]
      )
      
      
    })
    
    stopCluster(cl)
    
    
    ClassSummary<- pblapply(ClassSummary,FUN=function(X){
      cols<-colnames(X)[unlist(lapply(X,class))=="numeric"]
      X[,(cols) := round(.SD,ROUND), .SDcols=cols]
      X
    })
    
    Int<-unlist(lapply(ClassSummary,"[[",1,1))
    ClassSummary<-lapply(unique(Int),FUN=function(INT){
      rbindlist(ClassSummary[which(Int == INT)])
    })
    
    names(ClassSummary)<-unique(Int)
    
    
    Int<-unlist(lapply(BootClass,"[[",1,3))
    BootClass<-lapply(unique(Int),FUN=function(INT){
      rbindlist(BootClass[which(Int == INT)])
    })
    
    names(BootClass)<-unique(Int)
    
    Boot.Out<-list(Boot.Data=Boot.Data,BootClass=BootClass,ClassSummary=ClassSummary,Combo.Base=Combo.Base,Combo.Products=Combo.Products)
    
    if(!is.na(SaveDir)){
      
      save(Boot.Out,file=paste0(SaveDir,BootFile))
      
    }
  }
  
  return(Boot.Out)
}
```
:::: {style="display: flex;"}
::: {}

``` {r Boot - enable analysis,echo=F}
  selectInput("DoBoot", "Select enable to run bootstrapping ",choices = c("Enable","Pause"),selected="Pause", multiple = F)
```
:::
:::{}
``` {r Boot- choose number of reps,echo=F}
  numericInput("Reps","Reps. for bootstrapping (5-10000)",value=10000,min=5,max=10000,step=1)
```
:::
:::{}
``` {r Boot - Sample length,echo=F}
  selectInput("Boot.SampleStat", 
              "Resampling length statistic",
              choices = c("Max","Min"),
              selected="Min", 
              multiple = F)
```
:::
::::

```{r Boot - setup analysis,echo=F,include=F}
  # Set Parameters ####
  RemoveInt=T # Make interactive
  ROUND=5
  
  BootDir<-"Boot/"
```

```{r Boot - run analysis,echo=F,include=F}  
  Boot.Out<-reactive({
    if(input$DoBoot=="Enable"){

    BootSynergies(Data=data.table::copy(ERA), 
           PLevel=Prac.Levels[Choice == input$PLevel,Prac],
           OLevel=Out.Levels[Choice == input$OLevel,Out],
           rmOut=if(input$rmOut=="Yes"){T}else{F},
           Min.Studies=2,
           Min.Obs=5,
           RemoveInt=RemoveInt,
           Reps=input$Reps,
           cores=cores,
           ROUND=ROUND,
           SaveDir=BootDir,
           SampleLength=input$Boot.SampleStat)

  }else{
    NULL
  }
  })   
  
```

```{r Boot -  Subset Data on Min requirements}
 Boot.Class.Summary.SS.Fun<-function(Data,Studies,Observations){
   Y<-lapply(1:length(Data),FUN=function(i){
   X<-Data[[i]]
   X[,N1:=all(as.numeric(unlist(strsplit(N.Studies,"/")))>=Studies),by=Out.SubInd]
   X[,N2:=all(as.numeric(unlist(strsplit(N.Obs.Prac,"/")))>=Observations),by=Out.SubInd]
   X[,Nall:=all(c(N1,N2)),by=Out.SubInd]
   X<-X[Nall==TRUE]
   X[,N1:=NULL][,N2:=NULL][,Nall:=NULL]
   })
   names(Y)<-names(Data)
   Y<-Y[unlist(lapply(Y,nrow))>0]
   return(Y)
 }

Boot.Class.Summary.SS<-reactive({
  Boot.Class.Summary.SS.Fun(Data=Boot.Out()$ClassSummary,
                            Studies=input$Min.Studies,
                            Observations=input$Min.Obs)
})

 BootClass.SS.Fun<-function(DataClass,DataBoot){
     Z<-lapply(1:length(DataClass),FUN=function(i){
       Y<-DataBoot[[names(DataClass)[i]]]
       Y<-Y[Out.SubInd %in% DataClass[[i]][,unique(Out.SubInd)]]
       Y
     })
     
     names(Z)<-names(DataClass)
     
   Z<-Z[unlist(lapply(Z,nrow))>0]
   return(Z)
 }

 BootClass.SS<-reactive({
  BootClass.SS.Fun(DataClass=Boot.Class.Summary.SS(),
                    DataBoot=Boot.Out()$BootClass)
})

```

##### B2.1) Methods/Info

After data preparation (see Section A) ERA data are subset for each combination of a practice bundle and outcome. Bundles (`B`) and components (`C`) do not need to be co-located and outcome ratios are drawn from their overall populations in the data. For`B` and `C` populations of `ET/CT` ratios  and their linked weighting are randomly resampled to the minimum length of the smallest population. When the number of observations (`n`) of an outcome for `B` is 20, `Ca` is 12, and `Cb` is 19 then the resampling length for each dataset is 12. To generate weighted summed component (`SC`) ratios, component weights are divided by their sum, multiplied by the corresponding `ET/CT` ratio and then summed by row. The resampled `B` ratios are compared to each set of `C` ratios and their sum (`SC`) using two weighted t-tests with alternative hypotheses in differing directions (greater or lower). As the `SC` ratios are already weighted their weightings in the t-test are set to 1, otherwise the weightings generated in the data preparation phase (Section A) are supplied.  

The directionality of components was classified from t-test coefficients in order of divergent (any `C>0` and any `C<0`), positive (all `C>=0`), negative (all C<=0), and zero (all C = 0).   

Next the result of bundling is classified by comparison of t-test coefficients for B versus C or SC using logic corresponding using the logic described below and illustrated in Figure 1 of the manuscript that accompanies this markdown. For antagonistic, averaging, and additive classes p-values and significance at `P0.05` are derived from the maximum p-value of `B` vs `C` t-tests, the directionality of the alternative hypothesis depending on the class. For superadditive results the t-test for `B` vs `SC` is used to derive the p-value and if the directionality of `C` was divergent or negative, then `C` is substituted for `SC` when `SC<max(C)`. Classifications were as follows:  
1.	Antagonistic: `B<min(C)`. Alt. hypothesis = lower.  
2.	Averaging: `Bmin(C)` and `Bmax(C)`. Alt. hypothesis = lower when `B<Cn`, higher when `B>Cn`.  
3.	Additive: `B>max(C)` and `BSC`. Alt. hypothesis = higher.  
4.	Superadditive: `B>max(C)` and `B>SC`. Alt. hypothesis = higher.

Classifications were combined with significance at `P0.05` to give the nine bundle results presented in Section B2.2.   

The resampling and classification process was repeated 10,000 times and the proportion of each bundle result class calculated. The ridge plots in Section B2.2.1 illustrate the distributions of resampled `B`, `C` and `SC` coefficients. 


Note that the resampling and classification analysis is based  on proportional change and not differences. Whilst the simple classificaton of colocated data can use differencea, the resampling approach can compare only ratios as data are not colocated and the absolute differences are meaningless due to differences in units and experimental design between studies.   

Resampling uses `r renderText({input$Reps})` replicates.   

This is the function created to resample and classify data:
```{r Boot - Show Fucntion,echo=T}
BootSynergies
```

##### B2.2) Bar Plot {.tabset .tabset-fade .tabset-pills}
**Summary of total data available given minimum data requirements:**
```{r Plot Boot Data Summary Text,echo=F,eval=T}
Boot.Silver.Summary<-reactive({rbindlist(lapply(Boot.Class.Summary.SS(),FUN=function(X){
  X<-X[,list(PrName,Out.SubInd)]
  colnames(X)<-c("Practice","Outcome")
  X
}))})

renderText({
  paste0(
  paste0("Total data availability is ", Boot.Silver.Summary()[,length(unique(Practice))], " interactions of ", Boot.Silver.Summary()[,length(unique(unlist(strsplit(Practice,"-"))))]," ", input$PLevel,"s."),
    paste0("There are a total of ", Boot.Silver.Summary()[,length(unique(paste(Practice,Outcome)))]," ", input$OLevel," x Outcome ",input$OLevel, " combinations for ", Boot.Silver.Summary()[,length(unique(Outcome))]," Outcome ", input$OLevel,"s.")
  )
})
```

###### B2.2.1) Detailed (Bars + Ridges)

:::: {style="display: flex;"}
::: {}
```{r Boot - choose focal practice,echo = F}
  Int.Boot<-reactive({if(input$DoBoot=="Enable"){sort(names(Boot.Class.Summary.SS()))}else{NULL}})
  Pracs.Boot<-reactive({if(input$DoBoot=="Enable"){sort(unique(unlist(strsplit(Int.Boot(),"-"))))}else{NULL}})
  
  renderUI({
    if(input$DoBoot=="Enable"){
    selectInput("Focus", "Choose focal practice", 
    choices =  if(input$DoBoot=="Enable"){Pracs.Boot()}else{"Bootstrapping Not Enabled"}, 
    selected = if(input$DoBoot=="Enable"){"Inorganic Fertilizer"}else{"Bootstrapping Not Enabled"},
    multiple = F,
    width="200px")
    }else{
      NULL
    }
    })
  
```
:::
:::{}

```{r Boot Bar - Create table of Focal vs Non-Focal Pracs}
Int.Tab.Fun<-function(Focus,Int.Boot){
  Int.Tab<-Int.Boot[grep(Focus,Int.Boot)]
  
  for(SUB in paste0(c("-",Focus,""),c(Focus,"-",Focus))){
    Int.Tab<-gsub(SUB,"",Int.Tab)
  }
  
  Int.Tab<-data.table(Full.Name=Int.Boot[grep(Focus,Int.Boot)],Non.Focal=Int.Tab)
  Int.Vals<-sort(Int.Tab[,unique(unlist(strsplit(Non.Focal,"-")))])
  
  return(list(Int.Tab=Int.Tab,Int.Vals=Int.Vals))
}

Int.Tab<-reactive({
  if(input$DoBoot=="Enable"){Int.Tab.Fun(Focus=input$Focus,Int.Boot=Int.Boot())}else{NULL}
  })
```

```{r Boot Bar - choose interaction,echo = F}

  renderUI({
    selectInput(
    inputId="Boot.Bar.Int.Choice", 
    label = "Choose  interaction", 
    choices =  if(input$DoBoot=="Enable"){Int.Tab()$Int.Vals}else{"Bootstrapping Not Enabled"}, 
    selected = if(input$DoBoot=="Enable"){"Organic Fertilizer"}else{"Bootstrapping Not Enabled"},
    multiple = F,
    width="200px")
    })

Boot.Bar.Int.Choice2<-reactive({
  if(input$DoBoot=="Enable"){
   Int.Tab()$Int.Tab[grepl(paste(input$Boot.Bar.Int.Choice,collapse = "|"),Non.Focal),Full.Name]
  }else{NULL}
   })

```
:::
:::{}
```{r Boot Bar - choose bundles,echo=F }

renderUI({
 checkboxGroupInput(inputId="Boot.Bar.Bundles", 
                    label="Choose bundles to display:",
                    choices = Boot.Bar.Int.Choice2(),
                    selected= Boot.Bar.Int.Choice2(),
                    inline=T)
  })
```
:::
::::


```{r Boot Bar - select all or none outcomes,echo=F }
 checkboxGroupInput(inputId = "Silver.Bar.Out.None", 
                    label = "",
                    choices = c("Deselect all outcomes","Select all outcomes"),
                    selected="Select all outcomes",
                    inline=T)
```

```{r Boot Bar - choose outcomes,echo = F}

Boot.Bar.Out<-reactive({
 if(input$DoBoot=="Enable"){unique(unlist(lapply(Boot.Class.Summary.SS()[Boot.Bar.Int.Choice2()],"[[",2)))}else{NULL}
  })

  renderUI({
    checkboxGroupInput(
    inputId="Boot.Bar.Out.Choice", 
    label = "Choose  outcomes", 
    choices =  if(input$DoBoot=="Enable"){Boot.Bar.Out()}else{"Bootstrapping Not Enabled"}, 
    selected = if(input$DoBoot=="Enable"){
      if(input$Silver.Bar.Out.None=="Select all outcomes"){Boot.Bar.Out()}else{
        if(input$Silver.Bar.Out.None=="Select all outcomes"){NULL}else{
          if(is.null(input$Silver.Bar.Out.None)){Boot.Bar.Out()[1]}}}
      }else{"Bootstrapping Not Enabled"},
    inline = T)
    })
```

:::: {style="display: flex;"}
::: {}
```{r Boot - Adjust  Bar  Width, echo=F}
numericInput(inputId="Boot.Bar.Prop",
             label="Bar width",
             value=5,
             min=1,
             max=10,
             step=1,
             width="90px")
```
:::
::: {}
```{r Boot - Adjust Ridge Width, echo=F}
numericInput(inputId="Boot.Ridge.Prop",
             label="Ridge width",
             value=3,
             min=1,
             max=10,
             step=1,
             width="95px")
```
:::
::: {}
```{r Boot - Adjust Text Size, echo=F}
numericInput(inputId="Boot.Bar.Text",
             label="Text size",
             value=1,
             min=0.5,
             max=2,
             step=0.1,
             width="75px")
```
:::
::: {}
```{r Boot - Add Labels}
    selectInput(inputId="Boot.LabelBars",
                label="Label Bars?", 
                choices =  c("Yes","No"),
                selected = "Yes",
                multiple = F,
                width="90px")

```
:::
::: {}
```{r Boot - Label Axis}
    selectInput(inputId="Boot.LabelAxis",
                label="Label Axis?", 
                choices =  c("Yes","No"),
                selected = "No",
                multiple = F,
                width="90px")

```
:::
::: {}
```{r Boot - Split Labels}
    selectInput(inputId="Boot.Bar.SplitLabs",
                label="Split labs?", 
                choices =  c("Yes","No"),
                selected = "Yes",
                multiple = F,
                width="90px")

```
:::
::: {}
```{r Boot - Add no. studies}
    selectInput(inputId="Boot.Add.Nlabs",
                label="Add Nlabs?", 
                choices =  c("Yes","No"),
                selected = "Yes",
                multiple = F,
                width="90px")

```
:::
::: {}
```{r Boot - Adjust Individual Bar Height, echo=F}
numericInput(inputId="Boot.Bar.Height.Each",
             label="Bar height",
             value=20,
             min=10,
             max=100,
             step=5,
             width="90px")
```
:::
::: {}
```{r Boot - Reverse Colour Order, echo=F}
   selectInput(inputId="Boot.Bar.Rev.Order",
                label="Reverse colours?", 
                choices =  c("Yes","No"),
                selected = "Yes",
                multiple = F,
               width="120px")
```
:::
:::{}
```{r Boot - ShadowText, echo=F}
   selectInput(inputId="Boot.Bar.Shadow",
                label="Add shadow?", 
                choices =  c("Yes","No"),
                selected = "Yes",
                multiple = F,
               width="100px")
```
:::
:::{}
```{r Boot - Labels Face}
    selectInput(inputId="Boot.LabFace",
                label="Label face", 
                choices =  c("plain", "italic", "bold", "bold.italic"),
                selected = "bold",
                multiple = F,
                width="75px")

```
:::
::: {}
```{r Boot - Text Face}
    selectInput(inputId="Boot.TextFace",
                label="Text face", 
                choices =  c("plain", "italic", "bold", "bold.italic"),
                selected = "bold",
                multiple = F,
                width="75px")

```
:::
:::{}
```{r Boot - Outcome Order}
    selectInput(inputId="Boot.OutOrder",
                label="Outcome order", 
                choices =  c("alphabetical", "effect size"),
                selected = "alphabetical",
                multiple = F,
                width="120px")

```
:::
::::

:::: {style="display: flex;"}
::: {}
```{r Boot - Log Ridge X-axis, echo=F}
   selectInput(inputId="Boot.Bar.Ridge.Var",
                label="Choose x-axis variable", 
                choices =  c("Percent Change","Response Ratio"),
                selected = "Percent Change",
                multiple = F,
               width="200px")
```
:::
::: {}
```{r Boot - Adjust plot width, echo=F}
numericInput(inputId="Boot.BarPlot.Width",
             label="Plot width (mm)",
             value=300,
             min=50,
             max=1000,
             step=50,
             width="150px")
```
:::
::::

:::: {style="display: flex;"}
::: {}
```{r Boot - Bar Detailed Save Plot}
  selectInput(inputId="Boot.Bar.Save.Plot", 
              label="Save plot?",
              choices = c("Yes","No"),
              selected="No", 
              multiple = F,
              width="200px")
```
:::
:::{}
```{r Boot - Bar Detailed Filename, echo=F}
    textInput(inputId="Boot.Bar.Filename",
              label="Enter file name", 
              value="Enter text",
              width="200px")
            
```
:::
::::

```{r Boot -  plotdata 1 & 2 functions}
plotdata1<-function(DataBoot,Out.Choices,Int.Choices,SplitLabs,OutOrder,Add.Nlabs){

  X<-lapply(Int.Choices,FUN=function(INT){
    Data<-data.table(DataBoot[[INT]])
    Data<-Data[Out.SubInd %in% Out.Choices]
    if(nrow(Data)>0){
      
      # Rename Agroforestry Pruning and Crop Residue Incorporation
      Data[,PrName:=gsub("Mulch","Mulch (Herb)",PrName),by=PrName]
      Data[,PrName:=gsub("Agroforestry Pruning","Mulch (Tree)",PrName),by=PrName]
      Data[,PrName:=gsub("Crop Residue Incorporation","Residue Incorp.",PrName),by=PrName]
      Data[,PrName:=gsub("Fertilizer","Fert.",PrName),by=PrName]
      Data[,N.Studies:=gsub("/"," - ",N.Studies),by=N.Studies]
      Data[,Out.SubInd:=gsub("Water Use Efficiency","Rainfall Use Efficiency",Out.SubInd)]

      Data[,Weighting:=weighted.mean(c(Superadditive.Pr,Additive.Pr,Averaging.Pr),c(4,2,1)),by=list(PrName,Out.SubInd)]
      
      # Set NA values to 0
      cols<-colnames(Data)[unlist(lapply(Data,class))=="numeric"]
      FunA<-function(X){
        X[is.na(X)]<-0
        X
      }
      Data[,(cols) := FunA(.SD), .SDcols=cols]
      
      # Recalculate proportions so that we have % of each interaction type sig and non-sig
      Data2<-Data
      Data2[,Superadditive.Sig:=Superadditive.Pr*Superadditive.Pr.Sig
      ][,Superadditive.Sig.Subadd:=(Superadditive.Pr-Superadditive.Sig)*Superadditive.Pr.Sig.SubAdd
      ][,Superadditive:=Superadditive.Pr-Superadditive.Sig-Superadditive.Sig.Subadd]
      Data2[,Additive.Sig:=Additive.Pr*Additive.Pr.Sig
      ][,Additive:=Additive.Pr-Additive.Sig]
      Data2[,Averaging.Sig:=Averaging.Pr*Averaging.Pr.Sig
      ][,Averaging:=Averaging.Pr-Averaging.Sig]
      Data2[,Antagonistic.Sig:=Antagonistic.Pr*Antagonistic.Pr.Sig
      ][,Antagonistic:=Antagonistic.Pr-Antagonistic.Sig]
      
      Data2<-data.table::melt(Data2,id.vars = c("PrName","Out.SubInd","N.Studies","N.Obs.Prac","Weighting",grep("pc.mean|pc.diff",colnames(Data2),value=T)),variable.name = "Variable",value.name = "Value")
      
      # Subset data to interaction and proportions (proportion based on mean classification and proportion of those significant)
      DataP<-Data2[!grepl("[.]Tot|[.]NA|Positive|Divergent|Negative|[.]Pr|[.]mean|[.]Mean|.diff",Variable),]
      
      # Make Sure Interaction Type is correct ordered
      DataP[,Variable:=factor(Variable,levels=c("Superadditive.Sig","Superadditive.Sig.Subadd","Superadditive","Additive.Sig","Additive","Averaging.Sig","Averaging","Antagonistic.Sig","Antagonistic"))]
      
      # Weight outcomes to order results (outcome names only) used later on
      if(OutOrder!="Alphabetical"){
        X2<-unique(DataP[,list(Out.SubInd,Weighting)])[order(Weighting,decreasing = F),Out.SubInd]
      }else{
        X2<-DataP[,sort(unique(Out.SubInd))]
      }
      
      # Rename outcome subindicators so axis labels include the number of studies and observations
      if(Add.Nlabs=="Yes"){
      if(SplitLabs){
        DataP[,Out.SubInd:=paste0(Out.SubInd,"\n ",N.Studies)]
      }else{
        DataP[,Out.SubInd:=paste0(Out.SubInd," ",N.Studies)]
      }
      }else{
        DataP[,Out.SubInd:=gsub(" ","\n",Out.SubInd)]
      }
      
      # Weight outcomes to order results (outcome names only)
      X<-unique(DataP[,list(Out.SubInd,Weighting)])[order(Weighting,decreasing = F),Out.SubInd]
      DataP[,Out.SubInd:=factor(Out.SubInd,levels=X)]
      
      # Lable bars for hatching
      DataP[,Sig:="*"]
      DataP[!grepl(".Sig",Variable),Sig:="(NS)"]
      DataP[grepl("Superadditive.Sig.Subadd",Variable),Sig:="(*)"]
      
      # Rename columns
      setnames(DataP,"Variable","Interaction.Type")
      setnames(DataP,"Value","Proportion")
      
      # barplot(rep(length(Colours),length(Colours)), col=Colours) 
      
      DataP[grep("Super",Interaction.Type),Interaction.Type2:="Superadditive"]
      DataP[grep("Add",Interaction.Type),Interaction.Type2:="Additive"]
      DataP[grep("Superadditive.Sig.Add",Interaction.Type),Interaction.Type2:="Superadditive"]
      DataP[grep("Aver",Interaction.Type),Interaction.Type2:="Averaging"]
      DataP[grep("Antag",Interaction.Type),Interaction.Type2:="Antagonistic"]
      DataP[,Interaction.Type2:=factor(Interaction.Type2,levels=c("Superadditive","Additive","Averaging","Antagonistic"))
            ][,Interaction.Type3:=factor(paste(Interaction.Type2,Sig))]
      
      list(DataP=DataP,Order=X2)
      
      
    }else{
      return(NULL)
    }
  })
  
  names(X)<-Int.Choices
  X<-X[!unlist(lapply(X,is.null))]
  return(X)
}

plotdata2<-function(DataBoot,PlotData1,Out.Choices,Int.Choices){
  
  X<-lapply(Int.Choices,FUN=function(INT){
    Data<-data.table(DataBoot[[INT]])
    Data<-Data[Out.SubInd %in% Out.Choices]
    
    if(nrow(Data)>0){
      
      # Rename Long Practice Names
      Data[,PrName:=gsub("Mulch","Mulch (Herb)",PrName),by=PrName]
      Data[,PrName:=gsub("Agroforestry Pruning","Mulch (Tree)",PrName),by=PrName]
      Data[,PrName:=gsub("Crop Residue Incorporation","Residue Incorp.",PrName),by=PrName]
      Data[,PrName:=gsub("Fertilizer","Fert.",PrName),by=PrName]
      Data[,Out.SubInd:=gsub("Water Use Efficiency","Rainfall Use Efficiency",Out.SubInd)]

      
      cols<-c("pc_Int","pc_sum",grep("Mean.y",colnames(Data),value=T))
      X<-data.table::melt(Data,id.vars = c("PrName","Out.SubInd"),measure.vars = cols)
      X[,variable:=gsub("Mean.y_","",X[,variable])]
      X[variable=="pc_Int",variable:="Bundle"]
      X[variable=="pc_sum",variable:="Sum"]
      
      # Order variables
      X[,variable:=factor(variable,levels=c("Bundle","Sum",X[!variable %in% c("Sum","Bundle"),unique(variable)]))]
      
      # Order outcomes
      X[,Out.SubInd:=factor(X[,Out.SubInd],levels=rev(PlotData1[[INT]]$Order))]
      
      return(X)
    }else{
      return(NULL)
    }
  })
  
  names(X)<-Int.Choices
  X<-X[!unlist(lapply(X,is.null))]
  return(X)
}
```

```{r Boot - run plotdata1 function, echo=F}
    BootBarPlotData1 <- reactive({
       if(input$DoBoot=="Enable"){
      plotdata1(DataBoot=data.table::copy(Boot.Class.Summary.SS()),
                Out.Choices=input$Boot.Bar.Out.Choice,
                Int.Choices=input$Boot.Bar.Bundles,
                SplitLabs=if(input$Boot.Bar.SplitLabs=="Yes"){T}else{F},
                OutOrder=input$Boot.OutOrder,
                Add.Nlabs=input$Boot.Add.Nlabs)
       }else{
         NULL
       }
      })


```

```{r Boot - run plotdata2 function,echo=F}
      BootBarPlotData2 <-reactive({
        if(input$DoBoot=="Enable"){
          if(length(BootBarPlotData1())>0){
            plotdata2(DataBoot=data.table::copy(BootClass.SS()),
                      PlotData1=BootBarPlotData1(),
                      Out.Choices=input$Boot.Bar.Out.Choice,
                      Int.Choices=input$Boot.Bar.Bundles)
          }else{NULL}
        }else{NULL}
      })


```

```{r Boot - create plot function,echo=F,include=F}

Boot.BarPlot<-function(PlotData1,
                       PlotData2,
                       ColoursShort,
                       Alpha=0.75,
                       Text.Scale=1,
                       PlotWidth=300,
                       PlotHeight=30,
                       ShowTitle=T,
                       BarWidth=7,
                       RidgeWidth=3,
                       RevOrder=T,
                       Ridge.Axis,
                       AddShadow,
                       TextFace,
                       LabFace,
                       OutOrder,
                       LabelBars,
                       LabelAxis
                       ){
  
  g_legend<-function(a.gplot){
    tmp <- ggplot_gtable(ggplot_build(a.gplot))
    leg <- which(sapply(tmp$grobs, function(x) x$name) == "guide-box")
    legend <- tmp$grobs[[leg]]
    return(legend)}
  
  Colours1<-colorspace::adjust_transparency(ColoursShort,alpha=Alpha)
  Colours2<-colorspace::adjust_transparency(ColoursShort[1],alpha=Alpha*0.66)
  Colours3<-colorspace::adjust_transparency(ColoursShort,alpha=Alpha*0.33)
  
  ColoursShort<-c("Antagonistic *"  = Colours1[4],
                  "Antagonistic (NS)" = Colours3[4],
                  "Averaging *" = Colours1[3],
                  "Averaging (NS)" = Colours3[3],
                  "Additive *" = Colours1[2],
                  "Additive (NS)" = Colours3[2],
                  "Superadditive (*)" = Colours2,
                  "Superadditive (NS)" = Colours3[1],
                  "Superadditive *" = Colours1[1])
  
  Int.Choices<-names(PlotData1)
  
  Text.Sizes<-data.table("Axis.Title"=round(11*Text.Scale),
                "Axis.Text"=round(9*Text.Scale),
                "Label"=round(4*Text.Scale),
                "Plot.Title"=round(11*Text.Scale),
                "Legend.Text"=round(9*Text.Scale),
                "Legend.Title"=round(11*Text.Scale))
  
  if(length(Int.Choices)>0){
    
    Plots<-pblapply(1:length(Int.Choices),FUN=function(i){
      INT<-Int.Choices[i]
      print(i)
      PlotData1.Int<-data.table::copy(PlotData1[[i]])
      PlotData2.Int<-data.table::copy(PlotData2[[i]])
      
      X<-PlotData1.Int$DataP
      

      X[Out.SubInd=="Water Use Efficiency",Outcome:="Rainfall Use Efficiency"]


      if(OutOrder=="alphabetical"){
        X[,Out.SubInd:=as.character(Out.SubInd)
          ][,Out.SubInd:=factor(Out.SubInd,levels=sort(unique(Out.SubInd),decreasing = T))]
      }
  
    YLabs<-data.frame(Label=levels(X$Out.SubInd),
        Out.SubInd=levels(X$Out.SubInd),
        Proportion=0.01)
      
 
      Int.Order<-c("Antagonistic (NS)","Antagonistic *","Averaging (NS)","Averaging *","Additive (NS)","Additive *","Superadditive (NS)","Superadditive (*)","Superadditive *")
      
      
      if(RevOrder){
        X[,Interaction.Type3:=factor(Interaction.Type3,levels=rev(Int.Order))]
      }else{
        X[,Interaction.Type3:=factor(Interaction.Type3,levels=Int.Order)]
      }
      
      gBarplot<-ggplot2::ggplot(X,aes(x = Out.SubInd, y = Proportion))+                           
      ggplot2::geom_bar(stat = "identity",colour="grey30",aes(fill=Interaction.Type3),size=0.25)
      
      if(LabelBars=="Yes"){
      if(AddShadow=="Yes"){
      gBarplot<-gBarplot+ shadowtext::geom_shadowtext(data=YLabs, aes(label = Label, y=Proportion), vjust=0.5, hjust=0, size=Text.Sizes$Label,colour="black",bg.colour="white",fontface=LabFace)
      }else{
      gBarplot<-gBarplot+ ggplot2::geom_text(data=YLabs, aes(label = Label, y=Proportion), vjust=0.5, hjust=0, size=Text.Sizes$Label,check_overlap = TRUE,fontface=LabFace)
      }
      }
      
      
      gBarplot<-gBarplot+ggplot2::scale_fill_manual("Bundling\nResult",values=ColoursShort)+
      ggplot2::coord_cartesian(ylim=c(0.0001,1))+
      ggplot2::scale_y_continuous(expand = expansion(add=c(-0.0001,0.0001)))+
      ggplot2::coord_flip()+
      ggplot2::theme_bw()+
      ggplot2::theme(panel.grid =  ggplot2::element_blank(),
                                        panel.background = element_blank(),
                                        panel.border = element_blank(),
                                        panel.grid.minor = element_blank(),
                                        panel.grid.major = element_blank(),
                                        axis.ticks.y = element_blank(),
                                        legend.position = "bottom",
                                        axis.text.y =if(LabelAxis=="No"){
                                          element_blank()
                                          }else{
                                            element_text(size=Text.Sizes$Axis.Text,face=TextFace)},
                                        axis.text.x = element_text(size=Text.Sizes$Axis.Text,face=TextFace),
                                        axis.title.x =  element_text(size=Text.Sizes$Axis.Title,face=TextFace),
                                        axis.title.y =   element_blank(),
                                        plot.title = element_text(size=Text.Sizes$Plot.Title,face="bold", margin=margin(0,0,0,0)),
                                        legend.text = element_text(size=Text.Sizes$Legend.Text,face=TextFace),
                                        legend.title = element_text(size=Text.Sizes$Legend.Title,face="bold"),
                                        axis.line.x =  element_line(size = 0.3, colour = "grey10"))+
        ggplot2::labs(y = "Proportion")

      
      if(ShowTitle==T){
        gBarplot<-gBarplot+ggplot2::labs(title=gsub("-"," + ",X[1,PrName]))
      }
      
      PlotData2.Int[Out.SubInd=="Water Use Efficiency",Outcome:="Rainfall Use Efficiency"]

      if(OutOrder=="alphabetical"){
        PlotData2.Int[,Out.SubInd:=as.character(Out.SubInd)
          ][,Out.SubInd:=factor(Out.SubInd,levels=sort(unique(Out.SubInd)))]
      }
      
      
      PlotData2.Int[,variable:=gsub(" ","\n",variable)]
      
      Fixed<-c("Sum","Bundle")
      Variable<-PlotData2.Int[,unique(variable)]
      Order<-c(sort(Variable[!Variable %in% Fixed]),Fixed)
      
      PlotData2.Int[,variable:=factor(variable,levels=Order)]
      
      if(Ridge.Axis=="Response Ratio"){
        PlotData2.Int[,value:=log(1+value/100)]
        PlotData2.Int<-PlotData2.Int[!(is.na(value)|is.infinite(value))]
      }
      
      gridge<-ggplot2::ggplot(PlotData2.Int, aes(x=value, y=variable,fill=variable)) + 
        ggridges::geom_density_ridges(size=0.25) + 
        ggplot2::facet_grid(Out.SubInd~.)+
        ggplot2::geom_vline(xintercept = 0,lty="dashed")+
        ggplot2::theme_bw()+
        ggplot2::theme(axis.title.y = element_blank(),
                       axis.text.y = element_blank(),
                       axis.ticks.y = element_blank(),
                       panel.grid = element_blank(),
                       legend.position = "right",
                       strip.background = element_blank(),
                       strip.text = element_blank(),
                       plot.margin = margin(t=if(ShowTitle){5.5}else{-12},r= 22,b= 5.5,l=7.5,unit="pt"),
                       panel.background = element_blank(),
                       panel.border = element_blank(),
                       axis.text.x = element_text(size=Text.Sizes$Axis.Text,face=TextFace),
                       axis.title =  element_text(size=Text.Sizes$Axis.Title,face=TextFace),
                       plot.title = element_text(size=Text.Sizes$Plot.Title,face=TextFace),
                       legend.text = element_text(size=Text.Sizes$Legend.Text,face=TextFace),
                       legend.title = element_blank(),
                       axis.line.x =  element_line(size = 0.3, colour = "grey10"),
                       legend.background =  element_blank())+
        ggplot2::labs(x=Ridge.Axis,title="")+
        ggplot2::scale_fill_viridis_d(alpha=0.75,option="A")+
        ggplot2::guides(fill=guide_legend(title="Practice",reverse=T))
      
      # Extract legend

      Legend<-g_legend(gBarplot)
      
      # Join Plot 1 & 3 ####
      g<-gridExtra::grid.arrange(grobs=list(gBarplot + theme(legend.position="none"),
                                            gridge),
                                 widths=c(BarWidth,RidgeWidth))
      
      list(Plot=g,
           PlotHeight=PlotHeight+PlotHeight*PlotData2.Int[,length(unique(Out.SubInd))],
           N.Outcomes=PlotData2.Int[,length(unique(Out.SubInd))],
           Legend=Legend)
      
    })
    
    names(Plots)<-Int.Choices
    
    Plots<-Plots[!unlist(lapply(Plots,is.null))]
    
    if(length(Plots)>0){
      Heights<-unlist(lapply(Plots,"[[",3))*PlotHeight+PlotHeight
      Legend<-Plots[[1]][["Legend"]]
      Plots<-lapply(Plots,"[[",1)
      Plots$Legend<-Legend
      
      
      gt<-gridExtra::grid.arrange(grobs=Plots,
                                  ncol=1,
                                  heights=unit(c(Heights,PlotHeight),"mm"),
                                  widths=unit(PlotWidth,"mm"))
      
      return(list(Plot=gt,Heights=Heights))
    }else{
      return(NULL)
    }
    
  }else{
    return(NULL)
  }
  
}

```

```{r Boot - create plot,echo=F}

Boot.Bar.Plot<-reactive({
  if(input$DoBoot=="Enable"){
  Boot.BarPlot(PlotData1=BootBarPlotData1(),
             PlotData2=BootBarPlotData2(),
             ColoursShort=viridis::viridis(4, begin = 0,end = 1,option=input$BP.Palette),
             Alpha=input$BP.Alpha,
             Text.Scale=input$Boot.Bar.Text,
             PlotWidth=input$Boot.BarPlot.Width,
             PlotHeight=input$Boot.Bar.Height.Each,
             ShowTitle=T,
             BarWidth=input$Boot.Bar.Prop,
             RidgeWidth=input$Boot.Ridge.Prop,
             RevOrder=if(input$Boot.Bar.Rev.Order=="Yes"){T}else{F},
             Ridge.Axis = input$Boot.Bar.Ridge.Var,
             #ShortNames = input$BP.Bar.ShortNames,
             AddShadow = input$Boot.Bar.Shadow,
             TextFace = input$Boot.TextFace,
             LabFace = input$Boot.LabFace,
             OutOrder = input$Boot.OutOrder,
             LabelBars= input$Boot.LabelBars,
             LabelAxis=input$Boot.LabelAxis)
  }else{NULL}
  })
```

```{r Boot - BarPlot Width and Height Functions}

  Boot.Bar.Height <- function(){
    if(input$DoBoot=="Enable"){
           input$BP.Plot.Height*(sum(Boot.Bar.Plot()$Heights)*3+input$BP.Plot.Height*3)
    }else{
    NULL
    }}

  Boot.Bar.Width <- function(){
    if(input$DoBoot=="Enable"){
           input$BP.Plot.Width*900
    }else{
    NULL
  }}
  
```

```{r Boot - Plot Data,echo=F,eval=T}
  renderPlot({
        if(input$DoBoot=="Enable"){
       plot(Boot.Bar.Plot()$Plot)
        }
    },height=Boot.Bar.Height,width = Boot.Bar.Width)
  
```

```{r Boot - Save Bar Plot,echo = F}

reactive({
  if(input$Boot.Bar.Save.Plot=="Yes"){
   if(input$Boot.Bar.Filename != "Enter text here"){
    if(input$BP.Save.Format=="pdf"){
    ggsave(filename = paste0(input$Boot.Bar.Filename,".",input$BP.Save.Format),
           plot = Boot.Bar.Plot()$Plot,
           path = "./Plots",
           width= input$BP.Save.Width,
           height = input$BP.Save.Height,
           units = "mm",
           scale = input$BP.Save.Scale,
           dpi = input$BP.Save.Resolution,
           device = cairo_pdf)
    }else{
          ggsave(filename = paste0(input$Boot.Bar.Filename,".",input$BP.Save.Format),
           plot = Boot.Bar.Plot()$Plot,
           path = "./Plots",
           width= input$BP.Save.Width,
           height = input$BP.Save.Height,
           units = "mm",
           scale = input$BP.Save.Scale,
           dpi = input$BP.Save.Resolution,
           type = "cairo")
    }}}})


```



###### B2.2.2) Simple (Bars Only)
:::: {style="display: flex;"}
::: {}
```{r Boot - Bar Plot Simple Show Labels}
    selectInput(inputId="Boot.Bar.Simple.Labs",
                label="Show labels?", 
                choices =  c("Yes","No"),
                selected = "Yes",
                multiple = F,
                width="100px")

```
:::
:::{}
```{r Boot - Bar Plot Simple Facet Text Wrapping, echo=F}
numericInput(inputId="Boot.BarSimple.FacetLabWidth",
             label="Facet wrapping",
             value=30,
             min=5,
             max=60,
             step=1,
             width="120px")
```
:::
::: {}
```{r Boot - Bar Plot Simple Panel Spacing, echo=F}
numericInput(inputId="Boot.BarSimple.Panel.Space",
             label="Panel spacing",
             value=0.1,
             min=0,
             max=5,
             step=0.05,
             width="100px")
```
:::
::: {}
```{r Boot - Bar Plot Keep Strip Boot.BarSimple.StripLab}
    selectInput(inputId="Boot.BarSimple.StripLab",
                label="Strip labels?", 
                choices =  c("Yes","No"),
                selected = "Yes",
                multiple = F,
                width="100px")

```
:::
:::{}
```{r Boot - Bar Plot Simple Label Size, echo=F}
numericInput(inputId="Boot.BarSimple.LabSize",
             label="Label size",
             value=5,
             min=1,
             max=20,
             step=1,
             width="100px")
```
:::
::: {}
```{r Boot - Bar Plot Simple Labels Face}
    selectInput(inputId="Boot.Bar.Simple.LabFace",
                label="Label font face", 
                choices =  c("plain", "italic", "bold", "bold.italic"),
                selected = "bold",
                multiple = F,
                width="130px")

```
:::
::: {}
```{r Boot - Bar Plot Simple Text Face}
    selectInput(inputId="Boot.Bar.Simple.TextFace",
                label="Text font face", 
                choices =  c("plain", "italic", "bold", "bold.italic"),
                selected = "bold",
                multiple = F,
                width="130px")

```
:::
::: {}
```{r Boot - Simple Bar Shadow}
  selectInput(inputId="Boot.Bar.Simple.Shadow", 
              label="Shadow labels?",
              choices = c("Yes","No"),
              selected="Yes", 
              multiple = F,
              width="110px")
```
:::
:::{}
```{r Boot - Bar Plot Adjust Axis Text, echo=F}
numericInput(inputId="Boot.BarSimple.Fine.Adj.AxisLabs",
             label="Axis text size",
             value=1,
             min=0.1,
             max=2,
             step=0.1,
             width="125px")
```
:::
:::{}
```{r Boot - Bar Plot Adjust Strip Text, echo=F}
numericInput(inputId="Boot.BarSimple.Fine.Adj.StripLabs",
             label="Strip text size",
             value=1,
             min=0.1,
             max=2,
             step=0.1,
             width="125px")
```
:::
::::

:::: {style="display: flex;"}
::: {}
```{r Boot - Bar Plot Bar Width, echo=F}
numericInput(inputId="Boot.BarSimple.BarWidth",
             label="Bar width",
             value=1,
             min=0,
             max=5,
             step=0.05,
             width="100px")
```
:::
:::{}
```{r Boot - Bar Plot Legend Rows, echo=F}
numericInput(inputId="Boot.BarSimple.LegendRows",label="No. legend rows",value=2,min=1,max=5,step=1,width="150px")
```
:::
:::{}
```{r Boot - Simple Bar Legend Position}
  selectInput(inputId="Boot.BarSimple.LegPos", 
              label="Legend position",
              choices = c("bottom","right","left","top"),
              selected="bottom", 
              multiple = F,
              width="150px")
```
:::
::: {}
```{r Boot - Simple Bar Show Legend}
  selectInput(inputId="Boot.Bar.ShowLegend", 
              label="Show legend?",
              choices = c("Yes","No"),
              selected="Yes", 
              multiple = F,
              width="100px")
```
:::
::: {}
```{r Boot - YAxis}
  selectInput(inputId="Boot.Bar.YAxis", 
              label="Y-axis variable",
              choices = c("Practice","Outcome"),
              selected="Practice", 
              multiple = F,
              width="150px")
```
:::
::: {}
```{r Boot - Labels in or out of plot}
  selectInput(inputId="Boot.Bar.LabLoc", 
              label="Label position",
              choices = c("inside plot","outside plot"),
              selected="Practice", 
              multiple = F,
              width="150px")
```
:::
:::{}
```{r Boot - Min per group, echo=F}
numericInput(inputId="Boot.BarSimple.Nmin",
             label="Min N per panel",
             value=1,
             min=1,
             max=20,
             step=1,
             width="150px")
```
:::
:::{}
```{r Boot - Max per group, echo=F}
numericInput(inputId="Boot.BarSimple.Nmax",
             label="Max N per panel",
             value=50,
             min=2,
             max=100,
             step=1,
             width="150px")
```
:::
::::

:::: {style="display: flex;"}
::: {}
```{r Boot - Bar Simple Colour Picker}
 colourInput(inputId="Boot.Bar.Simple.Bar.Col",
             label="Select bar outline colour", 
             value="#0D0D0D")
```
:::
::: {}
```{r Boot - Simple Bar Save Plot}
  selectInput(inputId="Boot.Bar.Simple.Save.Plot", 
              label="Save plot?",
              choices = c("Yes","No"),
              selected="No", 
              multiple = F,
              width="200px")
```
:::
:::{}
```{r Boot - Simple Bar Filename, echo=F}
    textInput(inputId="Boot.Bar.Simple.Filename",
              label="Enter file name", 
              value="Enter text",
              width="200px")
            
```
:::
::::
```{r Boot - Bar Plot Simple choose outcome,echo=F}

  # Choose which outcomes to include or exclude in the analysis
  renderUI(checkboxGroupInput(inputId="Boot.Bar.Simple.Outcomes", 
                              label="Choose outcomes: ",
                              choices = BootBarSimpleData()[,sort(unique(Outcome))], 
                              selected=BootBarSimpleData()[,unique(Outcome)], 
                              inline=T))

BootBarSimpleData2a<-reactive({BootBarSimpleData()[Outcome %in% input$Boot.Bar.Simple.Outcomes]})


```


```{r Boot - Bar Plot Simple choose practice,echo=F}

  # Choose which outcomes to include or exclude in the analysis
  renderUI(checkboxGroupInput(inputId="Boot.Bar.Simple.Practices", 
                              label="Choose practices: ",
                              choices = BootBarSimpleData2a()[,sort(unique(Practice))], 
                              selected=BootBarSimpleData2a()[,unique(Practice)], 
                              inline=T))

BootBarSimpleData2<-reactive({BootBarSimpleData2a()[Practice %in% input$Boot.Bar.Simple.Practices]})


```

```{r Boot - Bar Simple create bar height and width functions}
  Boot.Bar.Simple.Height <- function(){
           20*input$BP.Plot.Height*nrow(unique(BootBarSimpleData2()[,list(Practice,Outcome)]))
  }

  Boot.Bar.Simple.Width <- function(){
           900*input$BP.Plot.Width
        }
```

```{r Boot - Bar Simple Prepare Data}
BootBarSimpleData<-reactive({
  rbindlist(lapply(Boot.Class.Summary.SS(),FUN = function(X){
  colnames(X)[1:2]<-c("Practice","Outcome")
  
  Cols<-grep("Pr.Sig",colnames(X))
  NA.Fun<-function(X){
    X[is.na(X)|is.nan(X)]<-0
    X[X==""]<-0
    return(X)
    }
  
  X[ , (Cols) := lapply(.SD, NA.Fun), .SDcols = Cols]

  
  X[,Superadditive.Pr.Sig.SubAdd:=Superadditive.Pr*(Superadditive.Pr.Sig.SubAdd-Superadditive.Pr.Sig)]
  X[Superadditive.Pr.Sig.SubAdd<0,Superadditive.Pr.Sig.SubAdd:=0]
  X[,Superadditive.Pr.Sig:=Superadditive.Pr*Superadditive.Pr.Sig]
  X[,Superadditive.Pr:=Superadditive.Pr-Superadditive.Pr.Sig.SubAdd-Superadditive.Pr.Sig]

  X[,Additive.Pr.Sig:=Additive.Pr*Additive.Pr.Sig]
  X[,Additive.Pr:=Additive.Pr-Additive.Pr.Sig]
  
  X[,Averaging.Pr.Sig:=Averaging.Pr*Averaging.Pr.Sig]
  X[,Averaging.Pr:=Averaging.Pr-Averaging.Pr.Sig]
  
  X[,Antagonistic.Pr.Sig:=Antagonistic.Pr*Averaging.Pr.Sig]
  X[,Antagonistic.Pr:=Antagonistic.Pr-Antagonistic.Pr.Sig]
  
  X[,Order:=2.5*Superadditive.Pr.Sig+
            2.25*Superadditive.Pr.Sig.SubAdd+
            2*Superadditive.Pr+
            1.5*Additive.Pr.Sig+
            1.25*Additive.Pr+
            Averaging.Pr+Averaging.Pr.Sig-
            2.5*Antagonistic.Pr.Sig-
            2*Antagonistic.Pr]

  
  Y<-melt(X,id.vars=c("Practice","Outcome","N.Studies","N.Obs.Prac","Order"),measure.vars=c("Superadditive.Pr","Additive.Pr","Averaging.Pr","Antagonistic.Pr","Superadditive.Pr.Sig","Superadditive.Pr.Sig.SubAdd","Additive.Pr.Sig","Averaging.Pr.Sig","Antagonistic.Pr.Sig"),variable.name="Interaction.Type",value.name="Proportion")
  
  
  Renames<-data.table(
    Old=c("Superadditive.Pr.Sig","Superadditive.Pr.Sig.SubAdd","Superadditive.Pr","Additive.Pr.Sig","Additive.Pr","Averaging.Pr.Sig","Averaging.Pr","Antagonistic.Pr.Sig","Antagonistic.Pr"),
    New=c("Superadditive *","Superadditive (*)","Superadditive (NS)", "Additive *", "Additive (NS)","Averaging *","Averaging (NS)","Antagonistic *","Antagonistic (NS)")
    )

  Y[,Interaction.Type:=Renames[match(Y[,Interaction.Type],Old),New]]
  Y[,Interaction.Type:=factor(Interaction.Type,levels=Renames[,New])]
  
  Y
  }))
})
```

```{r Boot - render Bar Plot Simple, echo = F,eval=T}

BootBarSimpleFun<-function(Data,
                           Palette,
                           Alpha,
                           Font.Size,
                           Fine.Adj.AxisLab,
                           Fine.Adj.StripLab,
                           ShowLabel,
                           ShortNames,
                           PanelSpacing,
                           FacetLabWidth,
                           Outline.Col,
                           DoShadow,
                           BarWidth,
                           KeepStripLabs,
                           ShowLegend,
                           LegendRows,
                           LegPos,
                           LabSize,
                           LabFace,
                           TextFace,
                           Yaxis,
                           LabelPos,
                           MinN,
                           MaxN){
  
 Colours1<-viridisLite::viridis(n=4, alpha = Alpha, begin = 0, end = 1, option = Palette)
 Colours2<-colorspace::adjust_transparency(Colours1[1],alpha=Alpha*0.66)
 Colours3<-colorspace::adjust_transparency(Colours1,alpha=Alpha*0.33)
  
  ColoursShort<-c("Antagonistic *"  = Colours1[4],
  "Antagonistic (NS)" = Colours3[4],
  "Averaging *" = Colours1[3],
  "Averaging (NS)" = Colours3[3],
  "Additive *" = Colours1[2],
  "Additive (NS)" = Colours3[2],
  "Superadditive (*)" = Colours2,
  "Superadditive (NS)" = Colours3[1],
  "Superadditive *" = Colours1[1])
  
  Data[,N.Studies:=gsub("/","-",N.Studies)]
  
  if(ShortNames=="Yes"){
    Data<-ShortPNames(Data,"Practice","Practice")
  }
  
  Data[Outcome=="Water Use Efficiency",Outcome:="Rainfall Use Efficiency"]

  Data[,Practice:=gsub("-"," + ",Practice),by=Practice]
  
    if(Yaxis=="Practice"){
      
      Data<-Data[,NPrac:=length(unique(Practice)),by=list(Outcome)][NPrac>=MinN & NPrac<=MaxN]
      
      if(LabelPos!="inside plot" & ShowLabel=="Yes"){
        Data[,Practice1:=paste0(Practice," (",N.Studies,")")]
        ShowLabel<-"No"
      }else{
          Data[,Practice1:=Practice]
        }
      
       if(ShowLabel=="Yes"){
         gBarplot<-ggplot(Data,aes(x = reorder(Practice1,Order), y = Proportion,fill=Interaction.Type,label=N.Studies))
       }else{
         gBarplot<-ggplot(Data,aes(x = reorder(Practice1,Order), y = Proportion,fill=Interaction.Type)) 
       }
      
      gBarplot<-gBarplot+
        facet_grid(Outcome~.,drop=T,scales = "free_y", labeller = label_wrap_gen(width=FacetLabWidth),space = "free_y")+
        labs(x ="Practice", y = "Proportion")

    }else{
      
        Data<-Data[,NOut:=length(unique(Outcome)),by=list(Practice)][NOut>=MinN & NOut<=MaxN]


      
        if(LabelPos!="inside plot" & ShowLabel=="Yes"){
          Data[,Outcome1:=paste0(Outcome," (",N.Studies,")")]
          ShowLabel<-"No"
        }else{
          Data[,Outcome1:=Outcome]
        }
      
      Data[,Outcome1:=factor(Outcome1,levels = sort(unique(Outcome1),decreasing = T))]
      
        if(ShowLabel=="Yes"){
         gBarplot<-ggplot(Data,aes(x = Outcome1, y = Proportion,fill=Interaction.Type,label=N.Studies))
       }else{
         gBarplot<-ggplot(Data,aes(x = Outcome1, y = Proportion,fill=Interaction.Type)) 
       }
      
      gBarplot<-gBarplot+
        facet_grid(Practice~.,drop=T,scales = "free_y", labeller = label_wrap_gen(width=FacetLabWidth),space = "free_y")+
        labs(x = "Outcome", y = "Proportion")
    }
  
    gBarplot<-gBarplot+geom_bar(stat = "identity",colour=Outline.Col,size=0.25,width=BarWidth)+
    scale_fill_manual("Interaction\nType",values=ColoursShort)+
    scale_y_continuous(expand = expansion(add=c(-0.0001,0.0001)))+
    coord_flip(ylim=c(0.0001,1))+
    theme_bw()+ 
    theme(panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          panel.background = element_rect(fill = "transparent"),
          panel.spacing = unit(PanelSpacing, "lines"),
          panel.border  = element_blank(),
          plot.background = element_rect(fill = "transparent"),          
          plot.margin=unit(c(0,5,0,0),"mm"),
          axis.ticks = element_blank(),
          axis.title.y =  element_blank(),
          axis.line = element_blank(),
          axis.text = element_text(size=Font.Size*Fine.Adj.AxisLab,face=TextFace, colour="black"),
          axis.title.x = element_text(size=Font.Size*Fine.Adj.AxisLab*1.1,face=TextFace),
          legend.background = element_blank(),
          legend.position = LegPos,
          legend.text = element_text(size=Font.Size*Fine.Adj.AxisLab,face=TextFace),
          legend.title = element_text(size=Font.Size*Fine.Adj.AxisLab*1.1,face=TextFace),
          strip.text.y = element_text(angle=0,hjust=0,size=Font.Size*Fine.Adj.StripLab,face=TextFace),
          strip.background = element_blank()
          )+
    guides(fill=guide_legend(nrow=LegendRows,byrow=F))
    
  if(KeepStripLabs=="No"){
      gBarplot<-gBarplot+theme(strip.text.y = element_blank())
    }
  
    if(ShowLabel=="Yes"){
      if(DoShadow=="Yes"){
         gBarplot<-gBarplot+shadowtext::geom_shadowtext(aes(y=0.01), hjust=0, colour="black",bg.colour="white", check_overlap = TRUE,size=LabSize,fontface=LabFace)
      }else{
         gBarplot<-gBarplot+geom_text(aes(y=0.01),hjust=0, check_overlap = TRUE,size=LabSize,fontface=LabFace)
      }
     }

    return(gBarplot)

}

BootBarPlotSimple<-reactive({BootBarSimpleFun(Data=data.table::copy(BootBarSimpleData2()),
                                              Palette=input$BP.Palette,
                                              Alpha=input$BP.Alpha,
                                              Font.Size = input$BP.Global.Font.Size,
                                              Fine.Adj.AxisLab = input$Boot.BarSimple.Fine.Adj.AxisLabs,
                                              Fine.Adj.StripLab = input$Boot.BarSimple.Fine.Adj.StripLabs,
                                              ShowLabel = input$Boot.Bar.Simple.Labs,
                                              ShortNames =  input$BP.Bar.ShortNames,
                                              PanelSpacing = input$Boot.BarSimple.Panel.Space,
                                              FacetLabWidth = input$Boot.BarSimple.FacetLabWidth,
                                              Outline.Col = input$Boot.Bar.Simple.Bar.Col,
                                              DoShadow = input$Boot.Bar.Simple.Shadow,
                                              BarWidth=input$Boot.BarSimple.BarWidth,
                                              KeepStripLabs=input$Boot.BarSimple.StripLab,
                                              ShowLegend = input$Boot.Bar.ShowLegend,
                                              LegendRows=input$Boot.BarSimple.LegendRows,
                                              LegPos=input$Boot.BarSimple.LegPos,
                                              LabSize=input$Boot.BarSimple.LabSize,
                                              LabFace=input$Boot.Bar.Simple.LabFace,
                                              TextFace=input$Boot.Bar.Simple.TextFace,
                                              Yaxis=input$Boot.Bar.YAxis,
                                              LabelPos=input$Boot.Bar.LabLoc,
                                              MinN=input$Boot.BarSimple.Nmin,
                                              MaxN=input$Boot.BarSimple.Nmax)
})


renderPlot({
  BootBarPlotSimple()
  },height=Boot.Bar.Simple.Height,width=Boot.Bar.Simple.Width)

```
Labels indicate data availability as No.Studies for the interaction followed by its component practices (as per order of interaction name).
```{r Boot - Save Bar Simple Plot Simple,echo = F}

reactive({
  if(input$Boot.Bar.Simple.Save.Plot=="Yes"){
   if(input$Boot.Bar.Simple.Filename != "Enter text here"){
    if(input$BP.Save.Format=="pdf"){
    ggsave(filename = paste0(input$Boot.Bar.Simple.Filename,".",input$BP.Save.Format),
           plot = BootBarPlotSimple(),
           path = "./Plots",
           width= input$BP.Save.Width,
           height = input$BP.Save.Height,
           units = "mm",
           scale = input$BP.Save.Scale,
           dpi = input$BP.Save.Resolution,
           device = cairo_pdf)
    }else{
          ggsave(filename = paste0(input$Boot.Bar.Simple.Filename,".",input$BP.Save.Format),
           plot = BootBarPlotSimple(),
           path = "./Plots",
           width= input$BP.Save.Width,
           height = input$BP.Save.Height,
           units = "mm",
           scale = input$BP.Save.Scale,
           dpi = input$BP.Save.Resolution,
           type = "cairo")
    }}}})


```

```{r Boot - Proportion Summary}

Boot.Total.Prop<-function(Data){
  Data<-data.table(Data)
  Data[,Proportion:=as.numeric(Proportion)]
  Data[is.na(Proportion)|Proportion=="",Proportion:=0]
  X<-Data[,list(Mean.Prop=round(mean(Proportion),3)),by=Interaction.Type][order(Interaction.Type)]
  return(X)
}

  renderDT({
      if(input$DoBoot=="Enable"){
      datatable(Boot.Total.Prop(Data=BootBarPlotSimple()$data),
                caption="Summary of interaction type proportions across all outcomes in plot above",
                extensions = 'Buttons',
                filter = "top",
                options = list(dom = 'Blfrtip',
                               buttons = c('copy', 'csv', 'excel', 'pdf', 'print'),
                               lengthMenu = list(c(10,25,50,-1),c(10,25,50,"All"))))
      }
      
    })

```

```{r Boot - high level summary stats, echo=F}

BootStudiesFun<-function(Boot.Out,BootBarPlotSimple,ERA,ShortNames){
  X<-data.table::copy(Boot.Out()$Combo.Base)
  
  if(ShortNames=="Yes"){
    X<-ShortPNames(X,"Combination","Practice")
  }
  
  X[,Practice:=gsub("-"," + ",Practice),by=Practice
    ][,PxO:=paste(Practice,Out.SubInd,collapse=" "),by=list(Practice,Out.SubInd)]
  
  Y<-BootBarPlotSimple$data
  Y[,PxO:=paste(Practice,Outcome),by=list(Practice,Outcome)]
  
  Studies<-X[PxO %in% Y[,PxO],unique(Code)]
  Locations<-unique(ERA[Code %in% Studies,list(Code,Country,FS_2012,AEZ5,AEZ16,Latitude,Longitude)])
  
  FarmingSystem<-Locations[,round(100*table(FS_2012,useNA="ifany")/nrow(Locations),2)]
  AEZ5<-Locations[,round(100*table(AEZ5,useNA="ifany")/nrow(Locations),2)]
  AEZ16<-Locations[,round(100*table(AEZ16,useNA="ifany")/nrow(Locations),2)]
  
  Table<-unique(Locations[,Studies:=length(unique(Code)),by=Country
                          ][,Total.Studies:=length(unique(Code))
                            ][,Perc:=round(100*(Studies/Total.Studies),2)
                              ][,list(Country,Studies,Perc)
                                ][order(Perc,decreasing = T)])

    return(list(Studies=Studies,Locations=Locations,Table=Table,FarmingSystem=FarmingSystem,AEZ5=AEZ5,AEZ16=AEZ16))
  
}

BootSimpleStudies<-reactive({BootStudiesFun(Boot.Out = Boot.Out(),
                                            BootBarPlotSimple = BootBarPlotSimple(),
                                            ERA = data.table::copy(ERA),
                                            ShortNames =  input$BP.Bar.ShortNames)})

```

This plot contains data from `r renderText({length(BootSimpleStudies()$Studies)})` studies across `r renderText({ BootSimpleStudies()$Locations[,length(unique(Country))] })` countries. More information on these studies can be found in the Bibliography tab of this section.

```{r Boot - HexPlot,echo=F}

ERAHexPlot<-function (Data, Low = "grey10", Mid = "grey50", High = "black", Point.Col = "yellow", Do.Log = "Yes", Showpoints = "No", 
    ALevel = NA,PointSize=0.5) {
    Data <- data.table(Data)
    if (!is.na(ALevel)) {
        Point.Data <- unique(Data[!(is.na(Latitude) | is.na(Longitude)), 
            list(Latitude, Longitude, ALevel)])
    }
    else {
        Point.Data <- unique(Data[!(is.na(Latitude) | is.na(Longitude)), 
            list(Latitude, Longitude)])
    }
    sites <- st_combine(st_as_sf(Point.Data, coords = c("Longitude", 
        "Latitude"), crs = 4326, agr = "constant"))
    AfricaMap <- getMap(resolution = "high")
    AfricaMap <- AfricaMap[AfricaMap$REGION == "Africa" & 
        !is.na(AfricaMap$REGION), ]
    AfricaMap <- st_as_sf(AfricaMap, crs = 4326)
    g <- ggplot(sites)
    
    if (Do.Log == "Yes") {
        g <- g + geom_hex(data = Point.Data, aes(x = Longitude, 
            y = Latitude, fill = stat(log(count)))) + scale_fill_gradient2("log(No. Studies)", 
            low = Low, mid = Mid, high = High)
    }
    else {
        g <- g + geom_hex(data = Point.Data, aes(x = Longitude, 
            y = Latitude)) + scale_fill_gradient2("No. Studies", 
            low = Low, mid = Mid, high = High)
    }
    
        if (Showpoints == "Yes") {
        g <- g + geom_sf(data = sites, size = PointSize, shape = 16, 
            colour = Point.Col, alpha = 1)
        }
    
    g <- g + theme_bw() + theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(), axis.text = element_blank(), 
        axis.ticks = element_blank(), axis.title = element_blank(), 
        legend.position = c(0.16, 0.27), legend.background = element_blank(), 
        legend.text = element_text(colour = "black", face = "bold"), 
        legend.title = element_text(colour = "black", face = "bold"))

    g <- g + geom_sf(data = AfricaMap, aes(x = LON, y = LAT), 
        fill = NA, col = "black") + coord_sf(xlim = c(-25, 
        65), ylim = c(-35, 35))
    return(g)
}

Boot.Simple.Hex<-reactive({ERAHexPlot(
    Data=BootSimpleStudies()$Locations,
    Low = "grey10",
    Mid = "grey50",
    High = "black",
    Point.Col = "yellow",
    Do.Log = "Yes",
    Showpoints = "Yes",
    ALevel = "Code")
})

renderPlot({
Boot.Simple.Hex()
})


```

:::: {style="display: flex;"}
::: {}
```{r Boot - Simple Hex Save Plot}
  selectInput(inputId="Boot.Bar.Simple.Hex.Save.Plot", 
              label="Save plot?",
              choices = c("Yes","No"),
              selected="No", 
              multiple = F,
              width="200px")
```
:::
:::{}
```{r Boot - Simple Bar Hex Filename, echo=F}
    textInput(inputId="Boot.Bar.Simple.Hex.Filename",
              label="Enter file name", 
              value="Enter text",
              width="200px")
            
```
:::
::::

These are the proportions of farming systems and agroecological zones for the studies contributing to the analysis above:
```{r Farmings Systems}
renderPrint({BootSimpleStudies()$FarmingSystem})
renderPrint({BootSimpleStudies()$AEZ5})
renderPrint({BootSimpleStudies()$AEZ16})
```



```{r Boot - Save Bar Simple Hex Plot Simple,echo = F}

reactive({
  if(input$Boot.Bar.Simple.Hex.Save.Plot=="Yes"){
   if(input$Boot.Bar.Simple.Hex.Filename != "Enter text here"){
    if(input$BP.Save.Format=="pdf"){
    ggsave(filename = paste0(input$Boot.Bar.Simple.Hex.Filename,".",input$BP.Save.Format),
           plot = Boot.Simple.Hex(),
           path = "./Plots",
           width= input$BP.Save.Width,
           height = input$BP.Save.Height,
           units = "mm",
           scale = input$BP.Save.Scale,
           dpi = input$BP.Save.Resolution,
           device = cairo_pdf)
    }else{
          ggsave(filename = paste0(input$Boot.Bar.Simple.Hex.Filename,".",input$BP.Save.Format),
           plot = Boot.Simple.Hex(),
           path = "./Plots",
           width= input$BP.Save.Width,
           height = input$BP.Save.Height,
           units = "mm",
           scale = input$BP.Save.Scale,
           dpi = input$BP.Save.Resolution,
           type = "cairo")
    }}}})

```

```{r Boot - Country Table}
 renderDT({
      datatable(BootSimpleStudies()$Table[order(Perc,decreasing = T)],
                caption="Countries contributing experimental studies to the interaction plot above",
                extensions = 'Buttons',
                filter = "top",
                options = list(dom = 'Blfrtip',
                               buttons = c('copy', 'csv', 'excel', 'pdf', 'print'),
                               lengthMenu = list(c(10,25,50,-1),c(10,25,50,"All")))) 
      
    })

```

```{r Boot - Bar simple render table, echo = F}
  renderDT({
      if(input$DoBoot=="Enable"){
      datatable(BootBarPlotSimple()$data[,!c("Order","Practice1")],
                caption="Data used in the interaction plot above",
                extensions = 'Buttons',
                filter = "top",
                options = list(dom = 'Blfrtip',
                               buttons = c('copy', 'csv', 'excel', 'pdf', 'print'),
                               lengthMenu = list(c(10,25,50,-1),c(10,25,50,"All"))))  %>% formatRound(columns = 6,4)
      }
      
    })
```

```{r Boot - Bar Simple Perc Summary}

renderDT({
      if(input$DoBoot=="Enable"){
      datatable(BootBarPlotSimple()$data[,TotalProp:=sum(Proportion)][,list(Perc=round(100*sum(Proportion)/TotalProp[1],4)),by=list(Interaction.Type)],
                caption="Boot-strapped data",
                extensions = 'Buttons',
                filter = "top",
                options = list(dom = 'Blfrtip',
                               buttons = c('copy', 'csv', 'excel', 'pdf', 'print'),
                               lengthMenu = list(c(10,25,50,-1),c(10,25,50,"All")))) # %>% formatRound(columns = c(5:12,16),3)
      }
})
  
```

###### B2.2.3) Data Table

`PrName` = Bundle, `Out.SubInd` = Outcome, `N.Studies` = number of studies (AB/A/B), `N.Obs.Prac` = number of observations (AB/A/B), `Int_pc.mean` =
weighted mean (WM) percent change of the interaction, `XXXXXX_pc.mean` = WM percent change for components (XXXXX = component name), `XXXXXX_pc.diff.mean` = WM interaction percent change minus component percent change, `XXXXXX_pc.diff.se` = standard error of `XXXXXX_pc.diff.mean`, `SumComps_pc.mean` = WM of the summed percent change of the components, `YYYYYYY.Pr` = proportion of samples in each bundling result class, `YYYYYY.Mean.Sig` = mean significance of samples for bundling result class, `YYYYYY.Pr.Sig.Tot` = proportion of all samples significant at P<0.05 for a bundle result class, `Superadditive.Pr.SubAdd.Tot` = the proportion of samples not significant at P<0.05 for the superadditive class but significant for additive class, `Averaging.Pr.Sig.Tot.NA` = proportion of averaging results that were NA (i.e. not significant), `YYYYYY.Pr.Sig` =  proportion of samples for a given bundle result class that are significant at P<0.05, `Positive.Pr` = proportion of samples where components are all positive, `Divergent.Pr` = proportion of samples where components have mixed signs (some + some -), and `Negative.Pr` = proportion of samples where  components are all negative.

```{r Boot - subset table, echo = F}

 Pracs.Boot.Table<-reactive({if(input$DoBoot=="Enable"){sort(unique(names(Boot.Out()$ClassSummary)))}else{NULL}})
  
  renderUI({
    selectInput(inputId="Focus.DT", 
    label="Choose focal combination", 
    choices =  if(input$DoBoot=="Enable"){Pracs.Boot.Table()}else{"Bootstrapping Not Enabled"}, 
    selected = if(input$DoBoot=="Enable"){Pracs.Boot.Table()[1]}else{"Bootstrapping Not Enabled"},
    multiple = F)
    })
```

```{r Boot - render table, echo = F}
  renderDT({
      if(input$DoBoot=="Enable"){
      datatable(Boot.Out()$ClassSummary[[input$Focus.DT]],
                caption="Boot-strapped data",
                extensions = 'Buttons',
                filter = "top",
                options = list(dom = 'Blfrtip',
                               buttons = c('copy', 'csv', 'excel', 'pdf', 'print'),
                               lengthMenu = list(c(10,25,50,-1),c(10,25,50,"All")))) # %>% formatRound(columns = c(5:12,16),3)
      }
      
    })

```

##### B2.3) Systematic Map {.tabset .tabset-fade .tabset-pills}
:::: {style="display: flex;"}
::: {}
```{r Boot - SMap choose concept}

  selectInput("BootSMap.Concept", 
              "Choose concept",
              choices = c("Base Practice","Product"),
              selected="Product", 
              multiple = F)

```
:::
:::{}
``` {r Boot - SMap choose product level}
  selectInput("Boot.EULevel", 
              "Level of product aggregation", 
              choices = EU.Levels[1:2,Choice], 
              selected = "Subtype", multiple = F)

```
:::
:::{}
``` {r Boot - SMap choose practice level}
  selectInput("Boot.PLevel", 
              "Level of practice aggregation", 
              choices = c("Practice","Theme"), 
              selected = "Theme", multiple = F)

```
:::
::::

```{r Boot - SMap Choose Outcomes}
  renderUI({checkboxGroupInput("Boot.SMap.Outcomes", 
              "Choose outcomes to display",
              choices = sort(Boot.Out()$Combo.Base[,unique(Out.SubInd)]),
              selected= Boot.Out()$Combo.Base[,unique(Out.SubInd)], 
              inline =T)})

```

###### B2.5.1) Bar Chart

:::: {style="display: flex;"}
::: {}
```{r Boot - SMap BarChart legend.position,eval=T}
  selectInput(inputId="Boot.SMap.Bar.LegPos", 
              label="Legend position",
              choices = c("right","bottom"),
              selected="bottom", 
              multiple = F,
              width="150px")

```
:::
:::{}
```{r Boot - SMap BarChart MinProp,eval=T}
      numericInput(inputId = "Boot.SMap.Bar.MinProp",
                   label = "Minimum proportion",
                   value = 0,
                   min = 0,
                   max = 1,
                   step = 0.01,
              width="150px")  
```
:::
:::{}
```{r Boot - SMap BarChart Lab Width,eval=T}
      numericInput(inputId = "Boot.SMap.Bar.LabWidth",
                   label = "Width of panel label before wrapping",
                   value = 30,
                   min = 5,
                   max = 50,
                   step = 1)  
```
:::
:::{}
```{r Boot - SMap BarChart Bar Width,eval=T}
      numericInput(inputId = "Boot.SMap.Bar.BarWidth",
                   label = "Bar width",
                   value = 1,
                   min = 0.1,
                   max = 10,
                   step = 0.1,
                  width="150px")  
```
:::
:::{}
```{r Boot - SMap BarChart Legend Rows,eval=T}
      numericInput(inputId = "Boot.SMap.Bar.LegendRows",
                   label = "Legend Rows",
                   value = 3,
                   min = 1,
                   max = 10,
                   step = 1,
                  width="150px")  
```
:::
:::{}
```{r Boot - SMap BarChart Panel Spacing,eval=T}
      numericInput(inputId = "Boot.SMap.Bar.PanelSpace",
                   label = "Panel Spacing",
                   value = 0.1,
                   min = 0,
                   max = 5,
                   step = 0.1,
                  width="150px")  
```
:::
::::

:::: {style="display: flex;"}
::: {}
```{r Boot - Bar SMap Detailed Save Plot}
  selectInput(inputId="Boot.SMap.Bar.Save.Plot", 
              label="Save plot?",
              choices = c("Yes","No"),
              selected="No", 
              multiple = F)
```
:::
:::{}
```{r Boot - Bar SMap Detailed Filename, echo=F}
    textInput(inputId="Boot.SMap.Bar.Filename",
              label="Enter file name", 
              value="Enter text")
            
```
:::
::::

```{r Boot - SMap BarChart create plots,eval=T,echo=F}

Boot.SMap.Plotter<-function(DataProd,DataBP,MinProp,Palette,Alpha,Text.Size,LegPos,Concept,EULevel,PLevel,Outcomes,MinStudies,FacetLabWidth, BarWidth,LegendRows,PanelSpacing){
  
  if(Concept=="Base Practice"){
    Data<-DataBP
    if(PLevel=="Practice"){
      Data[,Variable:=PrName.Base]
      FillLab<-"Base Practice"
    }else{
      Data[,Variable:=Theme.Base]
      FillLab<-"Base Theme"
    }
    
  }else{
    Data<-DataProd
      if(EULevel=="Product"){
      Data[,Variable:=Product.Simple]
      FillLab<-"Product Subtype"
    }else{
      Data[,Variable:=Product.Subtype]
        FillLab<-"Product"
    }
  }
  
  Data<-Data[Out.SubInd %in% Outcomes & Min.Studies>=MinStudies]
  
  Data[,Tot.Studies:=length(unique(Code)),by=list(Out.SubInd,Combination,Type)]
  
  Data<-Data[,list(Perc=length(unique(Code))/Tot.Studies[1]),by=list(Out.SubInd,Combination,Type,Variable)]

  Data[,Combination:=factor(Combination,levels=sort(Data[,unique(Combination)],decreasing = F))]

  g<-ggplot(Data[Perc>=MinProp],aes(x=Perc,y=Combination,fill=Variable))

  g<-g+geom_bar(stat="identity",width=BarWidth,colour="black",size=0.25)+
  scale_fill_viridis(discrete = T,option = Palette,alpha = Alpha)+
  theme_bw()+
  labs(y=NULL,
       x="Relative proportion (Studies)",
       fill=FillLab)+
  theme(legend.position = if(LegPos=="bottom"){"bottom"}else{"right"})+
  facet_grid(Out.SubInd~Type,scales = "free",space = "free_y",labeller = label_wrap_gen(width=FacetLabWidth))+
  scale_x_continuous(expand=c(0,0))+
  theme(text = element_text(size=Text.Size),
    panel.grid = element_blank(),
    panel.spacing.x = unit(PanelSpacing,"lines"),
    panel.spacing.y = unit(0,"lines"),
    axis.ticks.y = element_blank(),
    strip.background = element_blank(),
    strip.text.y = element_text(angle=0,hjust=0),
    strip.text = element_text(face="bold"))+
    guides(fill=guide_legend(nrow=LegendRows,byrow=T))


  return(g)
}

Boot.SMap.Bar.Plot<-reactive({
  Boot.SMap.Plotter(DataProd = Boot.Out()$Combo.Products,
                    DataBP =  Boot.Out()$Combo.Base,
                    MinProp = input$Boot.SMap.Bar.MinProp,
                    Palette =  input$BP.Palette,
                    Alpha = input$BP.Alpha,
                    Text.Size=input$BP.Global.Font.Size,
                    LegPos = input$Boot.SMap.Bar.LegPos,
                    Concept = input$BootSMap.Concept,
                    EULevel = input$Boot.EULevel,
                    PLevel = input$Boot.PLevel,
                    Outcomes = input$Boot.SMap.Outcomes,
                    MinStudies =  input$Min.Studies,
                    FacetLabWidth = input$Boot.SMap.Bar.LabWidth,
                    BarWidth  =  input$Boot.SMap.Bar.BarWidth,
                    PanelSpacing = input$Boot.SMap.Bar.PanelSpace,
                    LegendRows = input$Boot.SMap.Bar.LegendRows)
  })

```

```{r Boot - SMap Bar Simple create bar height and width functions}
  Boot.SMap.Bar.Simple.Height <- function(){
           20*input$BP.Plot.Height*nrow(unique(Boot.SMap.Bar.Plot()$data[,list(Combination,Out.SubInd)]))
  }

  Boot.SMap.Bar.Simple.Width <- function(){
           900*input$BP.Plot.Width
        }
```

```{r Boot - SMap BarChart Plot,eval=T,echo=F}
  renderPlot({Boot.SMap.Bar.Plot()},height=Boot.SMap.Bar.Simple.Height,width=Boot.SMap.Bar.Simple.Width)

```

```{r Boot - Save Bar Plot Simple,echo = F}

reactive({
  if(input$Boot.SMap.Bar.Save.Plot=="Yes"){
   if(input$Boot.SMap.Bar.Filename != "Enter text here"){
    if(input$BP.Save.Format=="pdf"){
    ggsave(filename = paste0(input$Boot.SMap.Bar.Filename,".",input$BP.Save.Format),
           plot = grid.arrange(Boot.SMap.Bar.Plot()),
           path = "./Plots",
           width= input$BP.Save.Width,
           height = input$BP.Save.Height,
           units = "mm",
           scale = input$BP.Save.Scale,
           dpi = input$BP.Save.Resolution,
           device = cairo_pdf)
    }else{
          ggsave(filename = paste0(input$Boot.SMap.Bar.Filename,".",input$BP.Save.Format),
           plot = grid.arrange(Boot.SMap.Bar.Plot()),
           path = "./Plots",
           width= input$BP.Save.Width,
           height = input$BP.Save.Height,
           units = "mm",
           scale = input$BP.Save.Scale,
           dpi = input$BP.Save.Resolution,
           type = "cairo")
    }}}})

```

###### B2.5.2) Data Table
```{r Boot - SMap Datatable,eval=T}

  renderDT({
      datatable(Boot.SMap.Bar.Plot()$data,
                caption="",
                extensions = 'Buttons',
                filter = "top",
                options = list(dom = 'Blfrtip',
                               buttons = c('copy', 'csv', 'excel', 'pdf', 'print'),
                               lengthMenu = list(c(10,25,50,-1),c(10,25,50,"All"))))
    }) 


```

##### B2.4) Bibliography
```{r Boot - Biblography - Choose Combination}
renderUI({
  selectInput(inputId="Boot.Biblio.Combo", 
              "Select combination",
              choices = Boot.Out()$Combo.Base[,sort(unique(Combination))],
              selected="Mulch-Reduced Tillage", 
              multiple = T)

})
```

```{r Boot - Bibliography}
BootBib.Studies<-reactive({
   unique(Boot.Out()$Combo.Base[Combination %in% input$Boot.Biblio.Combo,list(Combination,Type,Code)])
          })
               
BootBib.ERA<-reactive({
  data.table(
    BootBib.Studies(),
    ERA_Bibliography[ERACODE %in% BootBib.Studies()[,Code],list(AUTHOR,JOURNAL,YEAR,VOLUME,NUMBER,PAGES,TITLE,TYPE,DOI)]
  )
})

  renderDT({
      datatable(BootBib.ERA(),
                caption="Bibliography",
                extensions = 'Buttons',
                filter = "top",
                options = list(dom = 'Blfrtip',
                               buttons = c('copy', 'csv', 'excel', 'pdf', 'print'),
                               lengthMenu = list(c(10,25,50,-1),c(10,25,50,"All"))))
      
    })
```


#### B3) Co-located vs Resampling {.tabset .tabset-fade .tabset-pills}
Here we  will combine B1.2 with B2.2.2. Please make sure you have all outcomes selected in these sections for comparison. You will also need to enable bootstrapping in section B2 and have visited sections B2.2.2 and B1.2 for this section to work. The functions here use the data produced for these plots.

```{r Co-loc vs Boot - Prepare and Join Datasets}

JoinFun<-function(DataC,DataB){
  Data<-rbind(
    DataC[,Order:=NULL][,Source:="Co-located"][,list(Practice,Outcome,N.Studies,Interaction.Type,Proportion,Source)],
    DataB[,Order:=NULL][,Source:="Resampled"][,list(Practice,Outcome,N.Studies,Interaction.Type,Proportion,Source)]
  )
  
  
  Data<-Data[,N:=length(unique(Source)),by=list(Practice,Outcome)][N>1][,N:=NULL]
  
  return(Data)
}

DataCB<-reactive({
  JoinFun(DataC = data.table::copy(ColocatedBarPlot()$data),DataB=data.table::copy(BootBarPlotSimple()$data))
})

```

:::: {style="display: flex;"}
::: {}
```{r Co-loc vs Boot - Bar Plot Simple Show Labels}
    selectInput(inputId="CoBo.Bar.Simple.Labs",
                label="Show labels?", 
                choices =  c("Yes","No"),
                selected = "Yes",
                multiple = F,
                width="100px")

```
:::
:::{}
```{r Co-loc vs Boot - Bar Plot Simple Facet Text Wrapping, echo=F}
numericInput(inputId="CoBo.BarSimple.FacetLabWidth",
             label="Facet wrapping",
             value=30,
             min=5,
             max=60,
             step=1,
             width="120px")
```
:::
::: {}
```{r Co-loc vs Boot - Bar Plot Simple Panel Spacing, echo=F}
numericInput(inputId="CoBo.BarSimple.Panel.Space",
             label="Panel spacing",
             value=0.25,
             min=0,
             max=5,
             step=0.05,
             width="100px")
```
:::
::: {}
```{r Co-loc vs Boot - Bar Plot Keep Strip CoBo.BarSimple.StripLab}
    selectInput(inputId="CoBo.BarSimple.StripLab",
                label="Strip labels?", 
                choices =  c("Yes","No"),
                selected = "Yes",
                multiple = F,
                width="100px")

```
:::
:::{}
```{r Co-loc vs Boot - Bar Plot Simple Label Size, echo=F}
numericInput(inputId="CoBo.BarSimple.LabSize",
             label="Label size",
             value=5,
             min=1,
             max=20,
             step=1,
             width="100px")
```
:::
::: {}
```{r Co-loc vs Boot - Bar Plot Simple Labels Face}
    selectInput(inputId="CoBo.Bar.Simple.LabFace",
                label="Label font face", 
                choices =  c("plain", "italic", "bold", "bold.italic"),
                selected = "bold",
                multiple = F,
                width="130px")

```
:::
::: {}
```{r Co-loc vs Boot - Bar Plot Simple Text Face}
    selectInput(inputId="CoBo.Bar.Simple.TextFace",
                label="Text font face", 
                choices =  c("plain", "italic", "bold", "bold.italic"),
                selected = "bold",
                multiple = F,
                width="130px")

```
:::
::: {}
```{r Co-loc vs Boot - Simple Bar Shadow}
  selectInput(inputId="CoBo.Bar.Simple.Shadow", 
              label="Shadow labels?",
              choices = c("Yes","No"),
              selected="Yes", 
              multiple = F,
              width="110px")
```
:::
:::{}
```{r Co-loc vs Boot - Bar Plot Adjust Axis Text, echo=F}
numericInput(inputId="CoBo.BarSimple.Fine.Adj.AxisLabs",
             label="Axis text size",
             value=1,
             min=0.1,
             max=2,
             step=0.1,
             width="125px")
```
:::
:::{}
```{r Co-loc vs Boot - Bar Plot Adjust Strip Text, echo=F}
numericInput(inputId="CoBo.BarSimple.Fine.Adj.StripLabs",
             label="Strip text size",
             value=1,
             min=0.1,
             max=2,
             step=0.1,
             width="125px")
```
:::
::::

:::: {style="display: flex;"}
::: {}
```{r Co-loc vs Boot - Bar Simple Colour Picker}
 colourInput(inputId="CoBo.Bar.Simple.Bar.Col",
             label="Select bar outline colour", 
             value="#0D0D0D")
```
:::
::: {}
```{r Co-loc vs Boot - Bar Plot Bar Width, echo=F}
numericInput(inputId="CoBo.BarSimple.BarWidth",label="Bar width",value=1,min=0,max=5,step=0.05,width="100px")
```

:::
:::{}
```{r Co-loc vs Boot - Bar Plot Legend Rows, echo=F}
numericInput(inputId="CoBo.BarSimple.LegendRows",label="No. legend rows",value=2,min=1,max=5,step=1,width="150px")
```
:::
:::{}
```{r Co-loc vs Boot - Simple Bar Legend Position}
  selectInput(inputId="CoBo.BarSimple.LegPos", 
              label="Legend position",
              choices = c("bottom","right","left","top"),
              selected="bottom", 
              multiple = F,
              width="150px")
```
:::
::: {}
```{r Co-loc vs Boot - Simple Bar Show Legend}
  selectInput(inputId="CoBo.Bar.ShowLegend", 
              label="Show legend?",
              choices = c("Yes","No"),
              selected="Yes", 
              multiple = F,
              width="150px")
```
:::
::: {}
```{r Co-loc vs Boot - YAxis}
  selectInput(inputId="CoBo.Bar.YAxis", 
              label="Y-axis variable",
              choices = c("Practice","Outcome"),
              selected="Practice", 
              multiple = F,
              width="130px")
```
:::
::: {}
```{r Co-loc vs Boot - Shorten Outcomes?}
  selectInput(inputId="CoBo.Bar.ShortNamesO", 
              label="Abbreviate outcomes?",
              choices = c("Yes","No"),
              selected="No", 
              multiple = F,
              width="130px")
```
:::
::::

:::: {style="display: flex;"}
::: {}
```{r Co-loc vs Boot - Simple Bar Save Plot}
  selectInput(inputId="CoBo.Bar.Simple.Save.Plot", 
              label="Save plot?",
              choices = c("Yes","No"),
              selected="No", 
              multiple = F,
              width="200px")
```
:::
:::{}
```{r Co-loc vs Boot - Simple Bar Filename, echo=F}
    textInput(inputId="CoBo.Bar.Simple.Filename",
              label="Enter file name", 
              value="Enter text",
              width="200px")
            
```
:::
::::

```{r Co-loc vs Boot - Bar Plot Simple choose Practices,echo=F}

  # Choose which outcomes to include or exclude in the analysis
  renderUI(checkboxGroupInput(inputId="CoBo.Bar.Simple.Practices", 
                              label="Choose practices: ",
                              choices = DataCB()[,sort(unique(Practice))], 
                              selected=DataCB()[,unique(Practice)], 
                              inline=T))


DataCB2<-reactive({DataCB()[Practice %in% input$CoBo.Bar.Simple.Practices]})


```


```{r Co-loc vs Boot - Bar Plot Simple choose outcome,echo=F}

  # Choose which outcomes to include or exclude in the analysis
  renderUI(checkboxGroupInput(inputId="CoBo.Bar.Simple.Outcomes", 
                              label="Choose outcomes: ",
                              choices = DataCB2()[,sort(unique(Outcome))], 
                              selected=DataCB2()[,unique(Outcome)], 
                              inline=T))


DataCB3<-reactive({DataCB2()[Outcome %in% input$CoBo.Bar.Simple.Outcomes]})


```

```{r Co-loc vs Boot - Bar Simple create bar height and width functions}
  CoBo.Bar.Simple.Height <- function(){
           50*input$BP.Plot.Height*nrow(unique(DataCB2()[,list(Practice,Outcome)])) + 100
  }

  CoBo.Bar.Simple.Width <- function(){
           900*input$BP.Plot.Width
        }
```

```{r Co-loc vs Boot - create bar plot function & plot}
CoBo.BarSimpleFun<-function(Data,
                           Palette,
                           Alpha,
                           Font.Size,
                           Fine.Adj.AxisLab,
                           Fine.Adj.StripLab,
                           ShowLabel,
                           PanelSpacing,
                           FacetLabWidth,
                           Outline.Col,
                           DoShadow,
                           BarWidth,
                           KeepStripLabs,
                           ShowLegend,
                           LegendRows,
                           LegPos,
                           LabSize,
                           LabFace,
                           TextFace,
                           Yaxis,
                           ShortNamesO){
  
  Data[Interaction.Type=="Antagonistic",Interaction.Type:="Antagonistic *"
       ][Interaction.Type=="Averaging",Interaction.Type:="Averaging *"
         ][Interaction.Type=="Additive",Interaction.Type:="Additive *"
           ][Interaction.Type=="Superadditive",Interaction.Type:="Superadditive *"]
  

  
  
 Colours1<-viridisLite::viridis(n=4, alpha = Alpha, begin = 0, end = 1, option = Palette)
 Colours2<-colorspace::adjust_transparency(Colours1[1],alpha=Alpha*0.66)
 Colours3<-colorspace::adjust_transparency(Colours1,alpha=Alpha*0.33)
  
  ColoursShort<-c("Antagonistic *"  = Colours1[4],
  "Antagonistic (NS)" = Colours3[4],
  "Averaging *" = Colours1[3],
  "Averaging (NS)" = Colours3[3],
  "Additive *" = Colours1[2],
  "Additive (NS)" = Colours3[2],
  "Superadditive (*)" = Colours2,
  "Superadditive (NS)" = Colours3[1],
  "Superadditive *" = Colours1[1])
  
   if(Yaxis=="Practice"){

     if(ShowLabel=="Yes"){
       gBarplot<-ggplot(Data,aes(x = Practice, y = Proportion,fill=Interaction.Type,label=N.Studies))
     }else{
       gBarplot<-ggplot(Data,aes(x = Practice, y = Proportion,fill=Interaction.Type)) 
     }
     
     gBarplot<-gBarplot+
       facet_grid(Outcome~Source,drop=T,scales = "free_y", labeller = label_wrap_gen(width=FacetLabWidth),space = "free_y")+
       labs(x ="Practice", y = "Proportion")
    
   }else{

     if(ShortNamesO=="Yes"){
     Data<-ShortONames(Data,"Outcome","Outcome")
     }
     
     Data[,Outcome:=factor(Outcome,levels=sort(unique(Outcome)))]

    if(ShowLabel=="Yes"){
       gBarplot<-ggplot(Data,aes(x = Outcome, y = Proportion,fill=Interaction.Type,label=N.Studies))
     }else{
       gBarplot<-ggplot(Data,aes(x = Outcome, y = Proportion,fill=Interaction.Type)) 
     }
     
    gBarplot<-gBarplot+
      facet_grid(Practice~Source,drop=T,scales = "free_y", labeller = label_wrap_gen(width=FacetLabWidth),space = "free_y")+
      labs(x ="Outcome", y = "Proportion")
   }
  
    gBarplot<-gBarplot+geom_bar(stat = "identity",colour=Outline.Col,size=0.25,width=BarWidth)+
    scale_fill_manual("Interaction\nType",values=ColoursShort)+
    scale_y_continuous(expand = expansion(add=c(-0.0001,0.0001)))+
    coord_flip(ylim=c(0.0001,1))+
    theme_bw()+ 
    theme(panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          panel.background = element_rect(fill = "transparent"),
          panel.spacing = unit(PanelSpacing, "lines"),
          panel.border  = element_blank(),
          plot.background = element_rect(fill = "transparent"),          
          plot.margin=unit(c(0,5,0,0),"mm"),
          axis.ticks = element_blank(),
          axis.title.y =  element_blank(),
          axis.line = element_blank(),
          axis.text = element_text(size=Font.Size*Fine.Adj.AxisLab,face=TextFace, colour="black"),
          axis.title.x = element_text(size=Font.Size*Fine.Adj.AxisLab*1.1,face=TextFace),
          legend.background = element_blank(),
          legend.position = LegPos,
          legend.text = element_text(size=Font.Size*Fine.Adj.AxisLab,face=TextFace),
          legend.title = element_text(size=Font.Size*Fine.Adj.AxisLab*1.1,face=TextFace),
          strip.text.y = element_text(angle=0,hjust=0,size=Font.Size*Fine.Adj.StripLab,face=TextFace),
          strip.text.x = element_text(size=Font.Size*Fine.Adj.StripLab,face=TextFace),
          strip.background = element_blank())+
    guides(fill=guide_legend(nrow=LegendRows,byrow=F))
    
  if(KeepStripLabs=="No"){
      gBarplot<-gBarplot+theme(strip.text.y = element_blank())
    }
  
    if(ShowLabel=="Yes"){
      if(DoShadow=="Yes"){
         gBarplot<-gBarplot+shadowtext::geom_shadowtext(aes(y=0.01), hjust=0, colour="black",bg.colour="white", check_overlap = TRUE,size=LabSize,fontface=LabFace)
      }else{
         gBarplot<-gBarplot+geom_text(aes(y=0.01),hjust=0, check_overlap = TRUE,size=LabSize,fontface=LabFace)
      }
     }

    return(gBarplot)

}

CoBo.BarPlotSimple<-reactive({CoBo.BarSimpleFun(Data=data.table::copy(DataCB3()),
                                              Palette=input$BP.Palette,
                                              Alpha=input$BP.Alpha,
                                              Font.Size = input$BP.Global.Font.Size,
                                              Fine.Adj.AxisLab = input$CoBo.BarSimple.Fine.Adj.AxisLabs,
                                              Fine.Adj.StripLab = input$CoBo.BarSimple.Fine.Adj.StripLabs,
                                              ShowLabel = input$CoBo.Bar.Simple.Labs,
                                              PanelSpacing = input$CoBo.BarSimple.Panel.Space,
                                              FacetLabWidth = input$CoBo.BarSimple.FacetLabWidth,
                                              Outline.Col = input$CoBo.Bar.Simple.Bar.Col,
                                              DoShadow = input$CoBo.Bar.Simple.Shadow,
                                              BarWidth=input$CoBo.BarSimple.BarWidth,
                                              KeepStripLabs=input$CoBo.BarSimple.StripLab,
                                              ShowLegend = input$CoBo.Bar.ShowLegend,
                                              LegendRows=input$CoBo.BarSimple.LegendRows,
                                              LegPos=input$CoBo.BarSimple.LegPos,
                                              LabSize=input$CoBo.BarSimple.LabSize,
                                              LabFace=input$CoBo.Bar.Simple.LabFace,
                                              TextFace=input$CoBo.Bar.Simple.TextFace,
                                              Yaxis = input$CoBo.Bar.YAxis,
                                              ShortNamesO=input$CoBo.Bar.ShortNamesO)
})


renderPlot({
  CoBo.BarPlotSimple()
  },height=CoBo.Bar.Simple.Height,width=CoBo.Bar.Simple.Width)

```

```{r Co-loc vs Boot - Save Bar Simple Plot Simple,echo = F}

reactive({
  if(input$CoBo.Bar.Simple.Save.Plot=="Yes"){
   if(input$CoBo.Bar.Simple.Filename != "Enter text here"){
    if(input$BP.Save.Format=="pdf"){
    ggsave(filename = paste0(input$CoBo.Bar.Simple.Filename,".",input$BP.Save.Format),
           plot = CoBo.BarPlotSimple(),
           path = "./Plots",
           width= input$BP.Save.Width,
           height = input$BP.Save.Height,
           units = "mm",
           scale = input$BP.Save.Scale,
           dpi = input$BP.Save.Resolution,
           device = cairo_pdf)
    }else{
          ggsave(filename = paste0(input$CoBo.Bar.Simple.Filename,".",input$BP.Save.Format),
           plot = CoBo.BarPlotSimple(),
           path = "./Plots",
           width= input$BP.Save.Width,
           height = input$BP.Save.Height,
           units = "mm",
           scale = input$BP.Save.Scale,
           dpi = input$BP.Save.Resolution,
           type = "cairo")
    }}}})


```

### C) Approach 2 - Relative Improvements{.tabset .tabset-fade .tabset-pills}


``` {r AgGain - practice & outcome levels}
AgGain.PLevel<-reactive({Prac.Levels[Choice==input$PLevel,Prac]})

AgGain.OLevel<-reactive({Out.Levels[Choice==input$OLevel,Out]})

```


:::: {style="display: flex;"}
::: {}
```{r AgGain - Choose Variable, echo=F}
selectInput("AgGain.Variable", "Show response ratio or percent change?", 
    choices = c("Response ratio","Percent change","Median"), 
    selected = "Response ratio", multiple =  F)
```
:::
:::{}
```{r AgGain - subset Data 1,echo=F}
AgGain.Subset.Initial<-function(Data,OLevel,PLevel,Min.Studies,Min.Obs){
  Cols<-c(OLevel,paste0(PLevel,".Base"),PLevel)
  X<-ERAg::ERA.Compiled[!(is.na(SubPrName.Base)|is.na(yi)|is.infinite(yi)|SubPrName.Base=="")
                        ][,N.Out.Studies:=length(unique(Code)),by=Cols
                          ][,N.Out.Obs:=.N,by=Cols
                            ][N.Out.Studies>=Min.Studies & N.Out.Obs>=Min.Obs]
  
  return(X)
}

# Subset by data requirements given practice and outcome levels chosen
AgGain.Data<-reactive({AgGain.Subset.Initial(Data=data.table::copy(ERA),
                                   OLevel=AgGain.OLevel(),
                                   PLevel=AgGain.PLevel(),
                                   Min.Studies=input$Min.Studies,
                                   Min.Obs=input$Min.Obs)})

```
```{r AgGain - Choose Outcome,echo=F}

AgGain.Subset.Out<-function(Data,OLevel,Focal.Outcome){
  X<-unlist(Data[,..OLevel]) == Focal.Outcome
  return(Data[X])
}

AgGain.Subset.Out2<-function(Data,OLevel){
  return(unique(unlist(Data[,..OLevel])))
}


AgGain.Outcomes<-reactive({AgGain.Subset.Out2(Data = AgGain.Data(),OLevel=AgGain.OLevel())})

  renderUI({
    selectInput(
    inputId="AgGain.Focal.Outcome", 
    label = "Choose  outcome", 
    choices =  AgGain.Outcomes(),
    selected = if(input$OLevel=="Subindicator"){"Crop Yield"}else{
      if(input$OLevel=="Indicator"){"Product Yield"}else{
      if(input$OLevel=="Subpillar"){"Yield"}else{
      if(input$OLevel=="Pillar"){"Productivity"}}}},
    multiple = F)
    })
  
  # Subset by outcome
AgGain.Data2<-reactive({AgGain.Subset.Out(Data=AgGain.Data(),
                                OLevel=AgGain.OLevel(),
                                Focal.Outcome=input$AgGain.Focal.Outcome)})

```
:::
:::{}
```{r AgGain - Choose Base Practice,echo=F}

AgGain.Get.Base.Pracs<-function(Data,PLevel){
  Base<-paste0(PLevel,".Base")
  Cols<-c(Base,"Code")
  X<-unique(Data[,..Cols
                 ][,N.Studies:=length(unique(Code)),by=Base
                   ][,!"Code"])[order(N.Studies,decreasing = T)
                                ]
  X[,Choice:=apply(X,1,paste,collapse=" ")][,N.Studies:=NULL]
  
  return(X)
}

AgGain.BP.Choices<-reactive({AgGain.Get.Base.Pracs(Data=AgGain.Data2(),PLevel=AgGain.PLevel())})

AgGain.Outcomes<-reactive({AgGain.Subset.Out2(Data = AgGain.Data(),OLevel=AgGain.OLevel())})

  renderUI({
    selectInput(
    inputId="AgGain.Focal.BP2", 
    label = "Choose focal practice (# = studies)", 
    choices =  AgGain.BP.Choices()[,Choice],
    selected = AgGain.BP.Choices()[2,Choice],
    multiple = F)
    })
  
 AgGain.Focal.BP<-reactive({unlist(AgGain.BP.Choices()[Choice==input$AgGain.Focal.BP2,1])})
  
# Subset by focal practice
AgGain.Subset<-function(Data,PLevel,Focal.Practice){
  PLevel.Base<-paste0(PLevel,".Base")
  X<-unlist(Data[,..PLevel.Base]) == Focal.Practice
  return(Data[X])
}

AgGain.Data3<-reactive({AgGain.Subset(Data=AgGain.Data2(),
                            PLevel = AgGain.PLevel(),
                            Focal.Practice = AgGain.Focal.BP())})

```
:::
::::

```{r AgGain - Analyze Data,echo=F}
AgGain.Analyzed2<-reactive({ERAg::ERAAnalyze(Data=data.table::copy(AgGain.Data3()),
                              rmOut=if(input$rmOut=="Yes"){T}else{F},
                              Aggregate.By = c(AgGain.PLevel(),AgGain.OLevel())
                              )[,PC.median.pc:=100*(PC.median-1)]})

AgGain.Analyzed2.Rename<-function(Data){
colnames(Data)[1:2]<-c("Practice","Outcome")

return(Data)
}

AgGain.Analyzed<-reactive({
  AgGain.Analyzed2.Rename(Data=AgGain.Analyzed2())[,SigLab:=""
                                                   ][`RR.Pr(>|t|)`<=0.05,SigLab:="*"
                                                     ][`RR.Pr(>|t|)`<=0.01,SigLab:="**"
                                                       ][`RR.Pr(>|t|)`<=0.001,SigLab:="***"
                                                         ][Outcome=="Water Use Efficiency",Outcome:="Rainfall Use Efficiency"]
})

```

#### C1) Plot

:::: {style="display: flex;"}
::: {}
```{r AgGain - Show labels, echo=F}
selectInput(inputId="AgGain.Show.Lab", 
            label="Show labels?", 
            choices = c("Yes","No"), 
            selected = "Yes", 
            multiple =  F,
            width="100px")
```
:::
:::{}
```{r AgGain - Order by, echo=F}
selectInput(inputId="AgGain.Order", 
            label="Order bars by", 
            choices = c("Studies","Value"), 
            selected = "Value", 
            multiple =  F,
            width="120px")
```
:::
:::{}
```{r AgGain - Adjust Label Size, echo=F}
numericInput(inputId="AgGain.Text.Size.Lab",
             label="Label size",
             value=3.5,
             min=1,
             max=10,
             step=0.5,
             width="100px")
```
:::
:::{}
```{r AgGain - Errorbar Thickeness, echo=F}
numericInput(inputId="AgGain.Error.Thick",
             label="Error bar thickness",
             value=0.5,
             min=0.1,
             max=2,
             step=0.05,
             width="150px")
```
:::
::: {}

```{r AgGain - Bar Width, echo=F}
numericInput(inputId="AgGain.BarWidth",
             label="Bar outline",
             value=0.25,
             min=0.1,
             max=1,
             step=0.05,
             width="100px")
```
:::
::: {}
```{r AgGain - Bar Plot Simple Text Face}
    selectInput(inputId="AgGain.TextFace",
                label="Text font face", 
                choices =  c("plain", "italic", "bold", "bold.italic"),
                selected = "bold",
                multiple = F,
                width="120px")

```
:::
:::{}
```{r AgGain - Grid lines, echo=F}
selectInput(inputId="AgGain.Grid", 
            label="Remove grid lines?", 
            choices = c("Yes","No"), 
            selected = "Yes", 
            multiple =  F,
            width="150px")
```
:::
:::{}
```{r AgGain -Leg Pos X,echo=F}
numericInput(inputId="AgGain.LegPos.X",
             label="Legend X",
             value=0.8,
             min=0,
             max=1,
             step=0.05,
             width="80px")

```
:::
:::{}
```{r AgGain -Leg Pos Y,echo=F}
numericInput(inputId="AgGain.LegPos.Y",
             label="Legend Y",
             value=0.1,
             min=0,
             max=1,
             step=0.05,
             width="80px")

```
:::
::::

:::: {style="display: flex;"}
::: {}
```{r AgGain - Plot xlims lower,echo=F}

renderUI({numericInput("AgGain.Xlim1","Adjust x-limit lower",
             if(input$AgGain.Variable=="Response ratio"){
               if(AgGain.Analyzed()[,round(1.1*min(RR-RR.se),1)]>0){-0.2}else{AgGain.Analyzed()[,round(1.1*min(RR-RR.se),1)]}
               }else{
        if(input$AgGain.Variable=="Percent change"){
          if(AgGain.Analyzed()[,round(1.1*min(RR.pc.jen.low))]>0){-20}else{AgGain.Analyzed()[,round(1.1*min(RR.pc.jen.low))]}
        }else{
          if(input$AgGain.Variable=="Median"){
            if(AgGain.Analyzed()[,round(1.1*min(PC.median.pc))]>0){-20}else{AgGain.Analyzed()[,round(1.1*min(PC.median.pc))]}
        }}},
             min=if(input$AgGain.Variable=="Response ratio"){-4}else{
               if(input$AgGain.Variable=="Percent change"){-500}else{
                 if(input$AgGain.Variable=="Median"){-500}}},
             max=0,
             step=if(input$AgGain.Variable=="Response ratio"){0.02}else{1},
        width="200px")})
```
:::
:::{}
```{r AgGain - Plot xlims upper,echo=F}
renderUI({numericInput("AgGain.Xlim2","Adjust x-limit upper",
             if(input$AgGain.Variable=="Response ratio"){
               AgGain.Analyzed()[,round(1.1*max(RR+RR.se),1)]
               }else{
        if(input$AgGain.Variable=="Percent change"){
          AgGain.Analyzed()[,round(1.1*max(RR.pc.jen.high))]
        }else{
          if(input$AgGain.Variable=="Median"){
            AgGain.Analyzed()[,round(1.1*max(PC.median.pc))]
        }}},
             max=if(input$AgGain.Variable=="Response ratio"){4}else{
               if(input$AgGain.Variable=="Percent change"){500}else{
                 if(input$AgGain.Variable=="Median"){500}}},
             min=0,
             step=if(input$AgGain.Variable=="Response ratio"){0.02}else{1},width="200px")})

```
:::
::::

:::: {style="display: flex;"}
::: {}
```{r AgGain - Save Plot}
  selectInput(inputId="AgGain.Bar.Save.Plot", 
              label="Save plot?",
              choices = c("Yes","No"),
              selected="No", 
              multiple = F,
              width="150px")
```
:::
:::{}
```{r AgGain - Plot Filename, echo=F}
    textInput(inputId="Again.Bar.Filename",
              label="Enter file name", 
              value="Enter text here")
            
```
:::
::::

```{r AgGain - create bar height and width functions}
  AgGain.Bar.Height <- function(){
           15*input$BP.Plot.Height*nrow(AgGain.Analyzed())+200
  }

  AgGain.Bar.Width <- function(){
           900*input$BP.Plot.Width
  }
```

```{r AgGain - short names}
  AgGain.Analyzed.Plot<-reactive({
    if(input$BP.Bar.ShortNames=="Yes"){
      ShortPNames(data.table::copy(AgGain.Analyzed()),"Practice","Practice")
    }else{
      data.table::copy(AgGain.Analyzed())
    }
  })
  
```


```{r AgGain - create plot, echo = F}
AgGainBarPlot<-reactive({
  if(input$AgGain.Variable=="Response ratio"){
  if(input$AgGain.Order!="Studies"){
  g<-ggplot(data=AgGain.Analyzed.Plot(),aes(y=RR,x=factor(Practice,levels=AgGain.Analyzed.Plot()[order(RR,decreasing = F),Practice]),fill=Studies))
  }else{
    g<-ggplot(data=AgGain.Analyzed.Plot(),aes(y=RR,x=factor(Practice,levels=AgGain.Analyzed.Plot()[order(Studies ,decreasing = F),Practice]),fill=Studies))  
  }
    g<-g+geom_bar(stat="identity",colour="grey10",size=input$AgGain.BarWidth)+
    geom_errorbar(aes(ymin = RR - RR.se, ymax = RR + RR.se), 
                 colour = "grey50",
                 position = position_dodge2(preserve = "single"), size = input$AgGain.Error.Thick, width=0.25)+
    labs(y = "ln(Yield Ratio)")
    
    if(input$AgGain.Show.Lab=="Yes"){
     g<-g+geom_text(aes(y=ifelse(RR >= 0, -(max(RR)-min(RR))*0.02, (max(RR)-min(RR))*0.02),
                      label = paste0(round(RR, 1),SigLab, " (", Studies,")"),
                      hjust=ifelse(RR >= 0,1,0),check_overlap = TRUE),
                  size=input$AgGain.Text.Size.Lab,
                  fontface=input$AgGain.TextFace)
    }
}

if(input$AgGain.Variable=="Percent change"){
  if(input$AgGain.Order!="Studies"){
    g<-ggplot(data=AgGain.Analyzed.Plot(),aes(y=RR.pc.jen,x=factor(Practice,levels=AgGain.Analyzed.Plot()[order(RR.pc.jen,decreasing = F),Practice]), fill=Studies))
  }else{
    g<-ggplot(data=AgGain.Analyzed.Plot(),aes(y=RR.pc.jen,x=factor(Practice,levels=AgGain.Analyzed.Plot()[order(Studies ,decreasing = F),Practice]),fill=Studies))  
  }
  g<-g+geom_bar(stat="identity",colour="grey10",size=input$AgGain.BarWidth)+
    geom_errorbar(aes(ymin = RR.pc.jen.low, ymax = RR.pc.jen.high), 
                  colour = "grey50",
                  position = position_dodge2(preserve = "single"), width = input$AgGain.Error.Thick,size=0.45)+
    labs(y = "Percent change")
  

  if(input$AgGain.Show.Lab=="Yes"){
    g<-g+geom_text(aes(y=ifelse(RR.pc.jen >= 0, -(max(RR.pc.jen)-min(RR.pc.jen))*0.02, (max(RR.pc.jen)-min(RR.pc.jen))*0.02),
                       label = paste0(round(RR.pc.jen, 1),SigLab, " (", Studies,")"),
                       hjust=ifelse(RR.pc.jen >= 0,1,0),check_overlap = TRUE),
                   size=input$AgGain.Text.Size.Lab,
                   fontface=input$AgGain.TextFace)
  }
}

if(input$AgGain.Variable=="Median"){
  if(input$AgGain.Order!="Studies"){
    g<-ggplot(data=AgGain.Analyzed.Plot(),aes(y=PC.median.pc,x=factor(Practice,levels=AgGain.Analyzed.Plot()[order(PC.median.pc,decreasing = F),Practice]),fill=Studies))
  }else{
    g<-ggplot(data=AgGain.Analyzed.Plot(),aes(y=PC.median.pc,x=factor(Practice,levels=AgGain.Analyzed.Plot()[order(Studies ,decreasing = F),Practice]),fill=Studies))  
  }
  g<-g+geom_bar(stat="identity",colour="grey10",size=input$AgGain.BarWidth)+y = "Percent change"
  
  if(input$AgGain.Show.Lab=="Yes"){
    g<-g+geom_text(aes(y=ifelse(PC.median.pc >= 0, -(max(PC.median.pc)-min(PC.median.pc))*0.02, (max(PC.median.pc)-min(PC.median.pc))*0.02),
                       label = paste0(round(PC.median.pc, 1),SigLab, " (", Studies,")"),
                       hjust=ifelse(PC.median.pc >= 0,1,0),check_overlap = TRUE),
                   size=input$AgGain.Text.Size.Lab,
                   fontface=input$AgGain.TextFace)
  }
}

g<-g+coord_flip()+
  scale_fill_viridis(option = input$BP.Palette,alpha=input$BP.Alpha,trans="log10",direction = -1)+
  theme_bw()+
  theme(axis.title.y = element_blank(),
        text = element_text(size=input$BP.Global.Font.Size,face=input$AgGain.TextFace, color= "black"),
         axis.text = element_text(color = "black"),
        legend.position = c(input$AgGain.LegPos.X,input$AgGain.LegPos.Y),
        legend.box.margin = margin(c(0,0,0,0),unit="pt"),
        axis.ticks.y = element_blank())+
  ylim(input$AgGain.Xlim1,input$AgGain.Xlim2)+
  guides(fill = guide_colourbar(barwidth = 15,
                                barheight = 1,
                                title.position = "top",
                                direction = "horizontal"))

 
if(input$AgGain.Grid=="Yes"){
  g<-g+theme(panel.grid = element_blank())
}

g
})
```
`r renderText({paste0("Focal Practice = ",AgGain.Focal.BP())})`  
`r renderText({paste0("Outcome = ",input$AgGain.Focal.Outcome)})`
```{r AgGain - render plot, echo = F}
renderPlot({AgGainBarPlot()},height=AgGain.Bar.Height,width=AgGain.Bar.Width)
```

**If the below is blank, select the Systematic Map then Bibliography tab then return to this tab**


This plot contains data from `r renderText({length(AgGainSimpleStudies()$Studies)})` studies across `r renderText({ AgGainSimpleStudies()$Locations[,length(unique(Country))] })` countries. More information on these studies can be found in the Bibliography tab of this section. 

Numbers adjacent to bars indicate the mean x-axis value and following asterisks indicate significance * = P<=0.05, ** = P<=0.01, and  *** P<=0.01. Numbers in parenthesis indicate data availability as the number of studies used to estimate the mean result. Errors bars show standard error.  
When using response ratios x-axis values are calculated as log((Base Practice + Additional Practices)/Base Practice). When using percentage change x-axis values are calculated from the back-transformed exponent of log((Base Practice + Additional Practices)/Base Practice) correcting for the Jensen inequality.  
Significance is calculated using response ratios only.

```{r AgGain - Bar Plot Save,echo = F}

reactive({
  if(input$AgGain.Bar.Save.Plot=="Yes"){
    if(input$Again.Bar.Filename != "Enter text here"){
    if(input$BP.Save.Format=="pdf"){
    ggsave(filename = paste0(input$Again.Bar.Filename,".",input$BP.Save.Format),
           plot = AgGainBarPlot(),
           path = "./Plots",
           width= input$BP.Save.Width,
           height = input$BP.Save.Height,
           units = "mm",
           scale = input$BP.Save.Scale,
           dpi = input$BP.Save.Resolution,
           device = cairo_pdf)
    }else{
          ggsave(filename = paste0(input$Again.Bar.Filename,".",input$BP.Save.Format),
           plot = AgGainBarPlot(),
           path = "./Plots",
           width= input$BP.Save.Width,
           height = input$BP.Save.Height,
           units = "mm",
           scale = input$BP.Save.Scale,
           dpi = input$BP.Save.Resolution,
           type = "cairo")
    }}}})

```

```{r AgGain - high level summary stats, echo=F}
AgGainStudiesFun<-function(Data,ERA){

  Studies<-Data[,unique(Code)]
  Locations<-unique(ERA[Code %in% Studies,list(Code,Country,Latitude,Longitude)])

    return(list(Studies=Studies,Locations=Locations))
  
}

AgGainSimpleStudies<-reactive({AgGainStudiesFun(Data=AgGain.SMap.Data2(),ERA)})

```


```{r AgGain - HexPlot,echo=F}

AgainHex<-reactive({
    ERAHexPlot(
    Data=AgGainSimpleStudies()$Locations,
    Low = "grey10",
    Mid = "grey50",
    High = "black",
    Point.Col = "yellow",
    Do.Log = "Yes",
    Showpoints = "Yes",
    ALevel = "Code")
})

renderPlot({AgainHex()})


```

:::: {style="display: flex;"}
::: {}
```{r AgGain - Simple Hex Save Plot}
  selectInput(inputId="AgGain.Bar.Simple.Hex.Save.Plot", 
              label="Save plot?",
              choices = c("Yes","No"),
              selected="No", 
              multiple = F,
              width="200px")
```
:::
:::{}
```{r AgGain - Simple Bar Hex Filename, echo=F}
    textInput(inputId="AgGain.Bar.Simple.Hex.Filename",
              label="Enter file name", 
              value="Enter text",
              width="200px")
            
```
:::
::::

```{r AgGain - Save Bar Simple Hex Plot Simple,echo = F}

reactive({
  if(input$AgGain.Bar.Simple.Hex.Save.Plot=="Yes"){
   if(input$AgGain.Bar.Simple.Hex.Filename != "Enter text here"){
    if(input$BP.Save.Format=="pdf"){
    ggsave(filename = paste0(input$AgGain.Bar.Simple.Hex.Filename,".",input$BP.Save.Format),
           plot = AgainHex(),
           path = "./Plots",
           width= input$BP.Save.Width,
           height = input$BP.Save.Height,
           units = "mm",
           scale = input$BP.Save.Scale,
           dpi = input$BP.Save.Resolution,
           device = cairo_pdf)
    }else{
          ggsave(filename = paste0(input$AgGain.Bar.Simple.Hex.Filename,".",input$BP.Save.Format),
           plot = AgainHex(),
           path = "./Plots",
           width= input$BP.Save.Width,
           height = input$BP.Save.Height,
           units = "mm",
           scale = input$BP.Save.Scale,
           dpi = input$BP.Save.Resolution,
           type = "cairo")
    }}}})

```

```{r AgGain - Country Table}
 renderDT({
      datatable(unique(AgGainSimpleStudies()$Locations[,Studies:=length(unique(Code)),by=Country
                                                     ][,Total.Studies:=length(unique(Code))
                                                       ][,Perc:=round(100*(Studies/Total.Studies),2)
                                                         ][,list(Country,Studies,Perc)
                                                           ][order(Perc,decreasing = T)]),
                caption="Data used in the interaction plot above",
                extensions = 'Buttons',
                filter = "top",
                options = list(dom = 'Blfrtip',
                               buttons = c('copy', 'csv', 'excel', 'pdf', 'print'),
                               lengthMenu = list(c(10,25,50,-1),c(10,25,50,"All")))) 
      
    })

```


#### C2) Data Table
```{r AgGain - Datatable,eval=T}
  renderDT({
      datatable(AgGain.Analyzed()[,list(Practice,Observations,Studies,Sites,RR,RR.median,RR.se,`RR.t value`,`RR.Pr(>|t|)`,RR.pc.jen.low,RR.pc.jen,RR.pc.jen.high)],
                colnames=c("Practice","Observations","Studies","Sites","RR w.mean","RR w.median","RR w.se","RR t.val","RR sig","Perc-se","Perc mean","Perc+se"),
                caption="Productivity gain data underlying plot in section C1. RR = response ratio, Perc = percent change, w. = weighted, and se = standard error.",
                extensions = 'Buttons',
                filter = "top",
                options = list(dom = 'Blfrtip',
                               buttons = c('copy', 'csv', 'excel', 'pdf', 'print'),
                               lengthMenu = list(c(10,25,50,-1),c(10,25,50,"All")))) %>% formatRound(columns = c(5:12),3)
      
    })
```

#### C3) Systematic Map {.tabset .tabset-fade .tabset-pills}
:::: {style="display: flex;"}
::: {}
```{r AgGain - SMap choose summation field}

  selectInput("AgGain.SMap.Sum", 
              "Choose summation field",
              choices = c("Studies","Observations"),
              selected="Studies", 
              multiple = F)

```
:::
:::{}
``` {r AgGain - choose product level}
  selectInput("AgGain.EULevel", "Level of product aggregation", 
    choices = EU.Levels[,Choice], 
    selected = "Subtype", multiple = F)

AgGain.EULevel<-reactive({EU.Levels[Choice==input$AgGain.EULevel,Prod]})

```
:::
::::

```{r AgGain - SMap Rename Cols}
renameAgGain<-function(Data,PLevel,OLevel,EULevel){
  setnames(Data,PLevel,"Practice")
  setnames(Data,paste0(PLevel,".Base"),"Practice.Base")
  setnames(Data,OLevel,"Outcome")
  setnames(Data,"Product","ProductX")
  setnames(Data,EULevel,"Product")
  return(Data)
}

  AgGain.SMap.Data<-reactive({renameAgGain(Data= data.table::copy(AgGain.Data3()),
                PLevel = AgGain.PLevel(),
                OLevel = AgGain.OLevel(),
                EULevel = AgGain.EULevel())})

```


```{r AgGain - SMap Choose Interactions}
  renderUI({checkboxGroupInput("AgGain.SMap.Interactions", 
              "Choose Interactions",
              choices = AgGain.SMap.Data()[,sort(unique(Practice))],
              selected= AgGain.SMap.Data()[,sort(unique(Practice))], 
              inline =T)})

```

```{r AgGain - SMap subset data}
AgGain.SMap.Data2<-reactive({AgGain.SMap.Data()[Practice %in% input$AgGain.SMap.Interactions]})
```

```{r AgGain - SMap SMap.Fun2}

SMap.Fun2<-function(Data,Concept){
  X<-Data[,list(Studies=length(unique(Code)),Observations=.N),by=Concept]

  X[,Studies.Perc:=round(100*Studies/Data[,length(unique(Code))],2)
    ][,Observations.Perc:=round(100*Observations/nrow(Data),2)]
  
  return(X)
}

AgGain.SMap.Data3<-reactive({SMap.Fun2(Data=AgGain.SMap.Data2(),
                                  Concept=input$AgGain.SMap.Concept)})

```

##### C3.1) Bar Chart
```{r AgGain - SMap BarChart prepare data,eval=T}

AgGain.SMap.Tabulator<-function(Data){
  
    Concept<-"Product"
    
    Concept.List<-strsplit(unlist(Data[,..Concept]),"-")
    
    N<-unlist(lapply(Concept.List,length))
    
    NRows<-rep(1:nrow(Data),N)
  
    Z<-data.table(Practice=Data[,Practice],Code=Data[,Code])[,N.Obs.Total:=.N,by=Practice
                                                             ][,N.Studies.Total:=length(unique(Code)),by=Practice
                                                               ][NRows
                                                                 ][,Concept:=unlist(Concept.List)]

    Z<-Z[,list(Observations=.N,
            Observations.Perc=100*.N/N.Obs.Total,
            Studies=length(unique(Code)),
            Studies.Perc=100*length(unique(Code))/N.Studies.Total),
            by=c("Concept","Practice","N.Obs.Total","N.Studies.Total")]
    
    # Standardize values
    Z[,Studies.Stand:=round(Studies.Perc/sum(Studies.Perc),3),by=Practice]
    Z[,Observations.Stand:=round(Observations.Perc/sum(Observations.Perc),3),by=Practice]
    
    setnames(Z,"Concept",Concept)

  
  # Return elements as list
  
  return(Z)

}

AgGain.SMap.Bar.Data<-reactive({
  AgGain.SMap.Tabulator(Data=AgGain.SMap.Data2())
  })

```

:::: {style="display: flex;"}
::: {}

```{r AgGain - SMap BarChart choose Studies or observations,eval=T}
  selectInput(inputId="AgGain.SMap.Bar.StudOrObs", 
              label="Calculations by no. studies or obervations",
              choices = c("Studies","Observations"),
              selected="Studies", 
              multiple = F)

```
:::
::: {}
```{r AgGain - SMap BarChart legend.position,eval=T}
  selectInput(inputId="AgGain.SMap.Bar.LegPos", 
              label="Legend position",
              choices = c("Right","Bottom"),
              selected="Right", 
              multiple = F)

```
:::
:::{}
```{r AgGain - SMap BarChart MinProp,eval=T}
      numericInput(inputId = "AgGain.SMap.Bar.MinProp",
                   label = "Minimum proportion to display",
                   value = 0,
                   min = 0,
                   max = 1,
                   step = 0.01)  
```
:::
:::{}
```{r AgGain - SMap BarChart Barwidth,eval=T}
      numericInput(inputId = "AgGain.SMap.Bar.Barwidth",
                   label = "Bar width",
                   value = 1,
                   min = 0,
                   max = 10,
                   step = 0.1)  
```
:::
:::{}
```{r AgGain - SMap BarChart Plotly,eval=T}
  selectInput(inputId="AgGain.SMap.Bar.Plotly", 
              label="Show interactive plotly graph?",
              choices = c("Yes","No"),
              selected="Yes", 
              multiple = F)

```
:::
::::

:::: {style="display: flex;"}
::: {}
```{r AgGain - SMap BarChart Detailed Save Plot}
  selectInput(inputId="AgGain.SMap.Bar.Save.Plot", 
              label="Save plot?",
              choices = c("Yes","No"),
              selected="No", 
              multiple = F)
```
:::
:::{}
```{r AgGain - SMap BarChart Detailed Filename, echo=F}
    textInput(inputId="AgGain.SMap.Bar.Filename",
              label="Enter file name", 
              value="Enter text")
            
```
:::
::::


```{r AgGain - SMap BarChart create plots,eval=T,echo=F}

AgGain.SMap.Plotter<-function(Data,MinProp,StudiesOrObs,Palette,Alpha,Text.Size,LegPos,Barwidth){
   if(StudiesOrObs=="Studies"){
    g<-ggplot(Data[Studies.Stand>=MinProp],aes(x=Studies.Stand,y=Practice,fill=Product))
  }else{
    g<-ggplot(Data[Observations.Stand>=MinProp],aes(x=Observations.Stand,y=Practice,fill=Product))
  }
  g<-g+geom_bar(stat="identity",colour="black",size=0.25,width=Barwidth)+
  scale_fill_viridis(discrete = T,option = Palette,alpha = Alpha)+
  theme_bw()+
  theme(text = element_text(size=Text.Size),
        panel.grid = element_blank(),
        axis.ticks.y = element_blank(),
        axis.line = element_blank(),
        panel.border = element_blank())+
  labs(y=NULL,
       x=if(StudiesOrObs=="Studies"){
         "Relative proportion (Studies)"
       }else{
         "Relative proportion (Observations)"
       })+
  theme(legend.position = if(LegPos=="Bottom"){"bottom"}else{"right"})+
  scale_x_continuous(expand=c(0,0))
  
  return(g)
}

AgGain.SMap.Bar.Plot<-reactive({
  AgGain.SMap.Plotter(Data = AgGain.SMap.Bar.Data(),
                      MinProp = input$AgGain.SMap.Bar.MinProp,
                      StudiesOrObs=input$AgGain.SMap.Bar.StudOrObs,
                      Palette =  input$BP.Palette,
                      Alpha = input$BP.Alpha,
                      Text.Size=input$BP.Global.Font.Size,
                      LegPos = input$AgGain.SMap.Bar.LegPos,
                      Barwidth = input$AgGain.SMap.Bar.Barwidth)
  })

```

```{r AgGain - SMap BarChart create plotly,eval=T,echo=F}
AgGain.SMap.Plotly<-reactive({
  ggplotly(AgGain.SMap.Bar.Plot(),
           width=input$BP.Plot.Width*900,
           height=input$BP.Plot.Height*20*AgGain.SMap.Bar.Data()[,length(unique(Practice))]+200)
  })
  
```

```{r AgGain - SMap BarChart Plot,eval=T,echo=F}
  renderPlot({AgGain.SMap.Bar.Plot()},height=AgGain.Bar.Height,width=AgGain.Bar.Width)

```

```{r AgGain - SMap BarChart Ploty,eval=T,echo=F}
  renderPlotly({AgGain.SMap.Plotly()})
```

```{r AgGain - SMap BarChart,echo = F}

reactive({
  if(input$AgGain.SMap.Bar.Save.Plot=="Yes"){
   if(input$AgGain.SMap.Bar.Filename != "Enter text here"){
    if(input$BP.Save.Format=="pdf"){
    ggsave(filename = paste0(input$AgGain.SMap.Bar.Filename,".",input$BP.Save.Format),
           plot = grid.arrange(AgGain.SMap.Bar.Plot()),
           path = "./Plots",
           width= input$BP.Save.Width,
           height = input$BP.Save.Height,
           units = "mm",
           scale = input$BP.Save.Scale,
           dpi = input$BP.Save.Resolution,
           device = cairo_pdf)
    }else{
          ggsave(filename = paste0(input$AgGain.SMap.Bar.Filename,".",input$BP.Save.Format),
           plot = grid.arrange(AgGain.SMap.Bar.Plot()),
           path = "./Plots",
           width= input$BP.Save.Width,
           height = input$BP.Save.Height,
           units = "mm",
           scale = input$BP.Save.Scale,
           dpi = input$BP.Save.Resolution,
           type = "cairo")
    }}}})

```

##### C3.2) Data Table
```{r AgGain - SMap Datatable,eval=T}

  renderDT({
      datatable(AgGain.SMap.Bar.Data(),
                caption="",
                extensions = 'Buttons',
                filter = "top",
                options = list(dom = 'Blfrtip',
                               buttons = c('copy', 'csv', 'excel', 'pdf', 'print'),
                               lengthMenu = list(c(10,25,50,-1),c(10,25,50,"All")))) %>% formatRound(columns = c(6,8:10),3)
      
    }) 


```


#### C4) Bibliography
```{r AgGain - Bibliography}
  renderDT({
      datatable(
        data.table(AgGain.SMap.Data2()[,list(Code,Country,Practice,Practice.Base,Product)],
                   ERA_Bibliography[ERACODE %in% AgGain.SMap.Data2()[,Code], list(AUTHOR,JOURNAL,YEAR,VOLUME,NUMBER,PAGES,TITLE,TYPE,DOI)]),
                caption="Bibliography",
                extensions = 'Buttons',
                filter = "top",
                options = list(dom = 'Blfrtip',
                               buttons = c('copy', 'csv', 'excel', 'pdf', 'print'),
                               lengthMenu = list(c(10,25,50,-1),c(10,25,50,"All"))))
      
    })
```